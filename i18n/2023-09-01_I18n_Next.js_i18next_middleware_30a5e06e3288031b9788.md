<!--
title:   Next.js App router での Middleware の役割 (v13.1.0)
tags:    I18n,Next.js,i18next,middleware
id:      30a5e06e3288031b9788
private: false
-->

TODO
i18n
認証
のMiddlewareの調査と分離


Middleware について Next.js 公式ドキュメントを調査していきます。

# Next.js Middleware ドキュメント

Routing: Middleware | Next.js

https://nextjs.org/docs/app/building-your-application/routing/middleware

※Middleware  v13.1.0 時点のドキュメントになります。



# Middlewareの主な仕事

Authentication 認証、アクセスの許可（Webアプリに入れるかどうかの判断をします。）
Authorization 認可、アクセスの制御（各データの取得を許可します。）
リクエストとレスポンスを変更します。
ヘッダーの強化します。
URL リダイレクトを実装します。
送受信リクエストの追跡をします。
キャッシュ戦略 (頻繁にアクセスされるデータをキャッシュに保存します。)
Webアプリの閉鎖やメンテナンス (すべてのアクセスを禁止して、特定のページを表示します。)



# Middleware の欠点

Webアプリが複雑になる場合があります。
これにより、アプリケーションの開発、デプロイ、保守がより困難になる可能性があります。ミドルウェアによりアプリケーションのコストが増加する可能性があります。

アプリケーションに遅延を引き起こします。これは、アプリケーションがリクエストを処理する前にミドルウェア コードを実行する必要があるためです。



# Middlewareの拡張子

middleware.js
middleware.ts
この拡張子が使えます。



# Middleware の NextRequest と NextResponse

ブラウザからのリクエスト NextRequestを受け取り

NextResponseを次の相手に渡します。
渡す相手は、
Next.jsへそのまま渡したり
ブラウザを拒否したりします。

NextResponseのbodyに色々なデータを加工したりして渡します。



# Middlewareとは？の疑問

まず最初にユーザーからのリクエストを止めて、Middleware で様々な処理を行います。

Middleware にはマッチャーというものがあり、ユーザーからのリクエストのパスがマッチャーにマッチした場合に、この Middleware が実行されます。 Middleware が実行されなかった場合は、ユーザーのリクエストは Middleware を素通りして Next.js に渡されます。

Middleware が実行された場合は 次にユーザーに返すレスポンスを作成します。
そもそもMiddleware が最初から無い場合には 通常 Next.js が **レスポンスを作成** しますが、マッチャーにより引っかかったリクエストをMiddleware で行うので、 レスポンスを作成する作業を Middleware が行います。

たとえば、不正な リクエスト を弾いた場合に Middleware が Next.js の代わりにレスポンスを返すのでこの作業は必ず必要です。

なので、Middleware は Next.jsとは独立したバックエンドと考えたほうが早いですね。

毒見役というか、検閲役というか、そんな役割を Middleware に求められます。

受け付けたユーザーからのリクエストを毒見して、不正なリクエストなら受け付けられないというレスポンスをユーザーに返し、正常なリクエストをNext.jsに渡すようにする役割を担っています。

Middleware はレスポンスを作りますが、その中身は当然 空っぽです。
中身を作る作業はNext.jsで行うのですから、Middleware にそんな能力はありませんので返す形だけしか作れません。

実際のコードはこのようになります。

```middleware.ts

const res = NextResponse.next()

```

このように レスポンスを作ります。 しかしこの中身はレスポンスの形だけが決まっているだけの空っぽな const変数 です。

const 変数は 再代入出来ないという規則がありますが、配列やオブジェクトのだった場合、中身を変更することは可能です。

つまり この const の宣言は 箱の形だけは決まって変えられないけど、中身は空っぽな箱で色々詰められる ということになります。

これは ユーザーにもNext.jsにも渡すことが出来ます。中身的には単なる空っぽの箱ですが共通の規格なのでブラウザもNext.jsも利用することが可能だからです。

そして空っぽのレスポンスを作った後に、ユーザーからのリクエストの解析に入ります。

ユーザーからのリクエストはどんなものかを調べて、それに応じてそのままユーザーに返すか、Next.jsに引き渡すかを判断する処理を書きます。

これが middleware 基本的な考え方です。

**リクエストを受け取り、レスポンスを返す。**
これを繰り返します。

なので、

```
return NextResponse.next()

```

このようにそのままを返すということは、Middlewareで何も処理せずに、受け取ったものをそのままNext.jsにわたすという意味になります。


# サンプルを見てみる


ここでサンプルを見てみます。

Next.js には Middleware の↓公式サンプルがあります。

middleware

https://github.com/vercel/next.js/tree/canary/examples/middleware

↑このリポジトリの ↓ middleware.ts を見てみます。

```middleware.ts
import { NextRequest, NextResponse } from 'next/server'

export function middleware(request: NextRequest) {
  if (request.nextUrl.pathname === '/about') {
    return NextResponse.redirect(new URL('/redirected', request.url))
  }
  if (request.nextUrl.pathname === '/another') {
    return NextResponse.rewrite(new URL('/rewrite', request.url))
  }
  return NextResponse.next()
}

export const config = {
  matcher: ['/about/:path*', '/another/:path*'],
}

```

文法は2つのシンプルなif文と、何もなかったら 空のレスポンスを 返す return文 というごく単純なコードです。

NextRequestと NextResponse は単なる型です。

3行目のコード
request.nextUrl.pathname === '/about'

trueならばリダイレクトを行います。

7行目のコード
request.nextUrl.pathname === '/another'

trueならばリライトを行います。



## redirectと rewrite という2つの処理の違い

redirect
クライアントを別のURLに転送することを目的としています。

rewrite
クライアントがアクセスしたURLを別のURLに書き換えることを目的としています。



## const config

この const config は Middleware が自動的に読み込みます。

このコードでは matcher が設定してあり、ユーザーからのリクエストのパスがこの matcher にマッチした場合に、このMiddlewareが実行されます。

(matcher が設定してあるので マッチしないユーザーのリクエストはこの Middleware を通らないので、最後のReturn文は 実質的に到達不可能です。)



## Middleware の配置場所について

Middleware は
root/
app/
pages/
と同じ階層に配置できます。



## Middleware の実行パス

マッチャーにより引っかかったリクエストに対して実行します。
リクエストを解析したパスを 条件分岐で分けます。

マッチャーには正規表現を使用できます。

マッチャー
サンプルコードより

/about/:path*
/another/:path*

/about/や/another/
ユーザーのリクエストがこのパスにマッチした場合に、この Middleware が実行されます。

:path*
コロンは名前付きパラメータを表します。

プレースホルダー
:[文字列]

プレースホルダーとは、あらかじめ決まっていない値を表すために、一時的に置かれる場所のことを指します。プログラミングにおいては、プレースホルダーは、変数や引数、フォーマット文字列などの形で使用されます。
Webアプリケーションにおいては、URLのパスにプレースホルダーを使用することで、動的なページを生成することができます。
プログラミングにおいては、プレースホルダーは、可読性や保守性を高めるためにも重要な役割を果たします。

`matcher`の`:path*`はプレースホルダーの1つです。
`/about/:path*`というパスは、`/about`の後に`/`で区切られた任意の文字列を含むパスにマッチします。
例えば、`/about/foo`や`/about/bar/baz`にマッチします。

このように、 プレースホルダー を使用することで、動的なパスを扱うことができます。`matcher`には、他にもプレースホルダーがあります。例えば、`:id`は数値のIDを表し、`:slug`は文字列のスラッグを表します。

* は正規表現で、0回以上の繰り返しを表します。


複数のURLパターンをマッチさせることができます。

matcher: ['/about/:path*', '/dashboard/:path*'],

このように配列に入れることで、複数のパスのパターンを設定できます。

ここまでの説明で、
マッチャーで複数のパスを設定することができること、
そして、その複数のそれぞれ個別のパスに対して、それぞれ個別の処理を行いたい場合は、ifなどの条件式を使って、それぞれのパスに対して処理を行うことになります。

## /about/:path* にマッチする例

/about/   ＜＜0回以上の繰り返しなので、このパスにもマッチします。
/about/foo
/about/bar/baz


## startsWith()というメソッド

request.nextUrl.pathname

↑この pathname には startsWith() というメソッドがあります。

使用例
request.nextUrl.pathname.startsWith('/about')

/aboutにマッチするパスがあった場合に、この コード が実行されます。

# NextResponse

NextResponseのコードを遡ってみていくと(F12ボタン)

```
declare const INTERNALS: unique symbol;
export declare class NextResponse<Body = unknown> extends Response {
    [INTERNALS]: {
        cookies: ResponseCookies;
        url?: NextURL;
        body?: Body;
    };
    constructor(body?: BodyInit | null, init?: ResponseInit);
    get cookies(): ResponseCookies;
    static json<JsonBody>(body: JsonBody, init?: ResponseInit): NextResponse<JsonBody>;
    static redirect(url: string | NextURL | URL, init?: number | ResponseInit): NextResponse<unknown>;
    static rewrite(destination: string | NextURL | URL, init?: MiddlewareResponseInit): NextResponse<unknown>;
    static next(init?: MiddlewareResponseInit): NextResponse<unknown>;
}

```

こんな感じです、ジェネリック型というものが使われています。
そのジェネリック型はBodyでありデフォルト値はunknownです。


つまり NextResponseは基本の値は全て決まっていてあとから
開発者がBodyにデータを入れる形になっているということになります。

開発者はこのBodyにMiddleware で加工したデータを入れていきます。



[INTERNALS]は配列ではなくて、2015年に追加されたシンボルです。

シンボルとは、プリミティブ型の一種で、文字列と似ていますが、文字列とは異なり、同じ値を持つシンボルは必ず異なるものとして扱われます。
unique symbolと宣言されているので、このシンボルは一意であることが保証されています。



## NextResponseの解説

```typescript
declare const INTERNALS: unique symbol;
```

`const`キーワードを使用して、`INTERNALS`という名前の定数を宣言しています。`unique symbol`は、一意のシンボルを表す型です。

```typescript
export declare class NextResponse<Body = unknown> extends Response {
```

`NextResponse`というクラスを宣言しています。`<Body = unknown>`は、ジェネリック型の宣言で、`Body`という型引数を持ち、デフォルト値として`unknown`を指定しています。`extends Response`は、`NextResponse`が`Response`クラスを継承することを示しています。

```typescript
[INTERNALS]: {
    cookies: ResponseCookies;
    url?: NextURL;
    body?: Body;
};
```

`[INTERNALS]`というプロパティに、`cookies`、`url`、`body`というプロパティを持つオブジェクトを定義しています。`cookies`は、`ResponseCookies`型、`url`は、`NextURL`型、`body`は、`Body`型です。

```typescript
constructor(body?: BodyInit | null, init?: ResponseInit);
```

`constructor`メソッドを定義しています。`body`と`init`という2つの引数を持ちます。`body`は、`BodyInit`型または`null`、`init`は、`ResponseInit`型です。

```typescript
get cookies(): ResponseCookies;
```

`cookies`というgetterメソッドを定義しています。戻り値の型は、`ResponseCookies`です。

```typescript
static json<JsonBody>(body: JsonBody, init?: ResponseInit): NextResponse<JsonBody>;
```

`json`という静的メソッドを定義しています。`<JsonBody>`は、ジェネリック型の宣言で、`JsonBody`という型引数を持ちます。`body`と`init`という2つの引数を持ちます。戻り値の型は、`NextResponse<JsonBody>`です。

```typescript
static redirect(url: string | NextURL | URL, init?: number | ResponseInit): NextResponse<unknown>;
```

`redirect`という静的メソッドを定義しています。`url`と`init`という2つの引数を持ちます。`url`は、`string`型、`NextURL`型、`URL`型のいずれかを受け取ることができます。`init`は、`number`型または`ResponseInit`型です。戻り値の型は、`NextResponse<unknown>`です。

```typescript
static rewrite(destination: string | NextURL | URL, init?: MiddlewareResponseInit): NextResponse<unknown>;
```

`rewrite`という静的メソッドを定義しています。`destination`と`init`という2つの引数を持ちます。`destination`は、`string`型、`NextURL`型、`URL`型のいずれかを受け取ることができます。`init`は、`MiddlewareResponseInit`型です。戻り値の型は、`NextResponse<unknown>`です。

```typescript
static next(init?: MiddlewareResponseInit): NextResponse<unknown>;
```

`next`という静的メソッドを定義しています。`init`という1つの引数を持ちます。`init`は、`MiddlewareResponseInit`型です。戻り値の型は、`NextResponse<unknown>`です。

以上が、`NextResponse`クラスの定義に関する解説です。

このクラスは、Next.jsのMiddlewareで使用されるレスポンスオブジェクトを拡張したものであり、`redirect`や`rewrite`などのメソッドを提供しています。

以上がNextResponseの簡易な説明です。



# 2つ目の Middleware 

Middleware で1つのチェックをする方法は学びました、次は複数のチェックをする場合、Middleware で実現するのはどうすればいいかと言う問題が出てきましたので調べたいと思います。


定義





<details><summary>Middleware を調べた時に躓いたこと</summary>

Middlewareを調べていて
最初に躓くのが Middleware 自身の理解とその立ち位置

自分は、フロントエンド、バックエンド、DBに続く第4番目の役割、立ち位置と考えています。

認証は扉をつくって鍵をかけ、開くという役割。
DBはRLS(Row Level Security)等のポリシーで鍵をかけますが、

Middleware は 門番という役割でしょうか。
全通信のチェックをします。

次が見知らぬ文法でした。
オブジェクトに配列記号の[]を使ってシンボルを作るとうことを初めて勉強しました。

そして第三の壁が 2つ目のMiddleware を追加する時どうすればいいのかという問題でした。

</details>

2つ目の Middleware を 実装する方法を調べていきます。




# 複数の処理をmiddleware.ts 1ファイルで行う？

まずは0個の処理、つまり受け流すだけの処理を書きます。

でもその前に1つ問題です。

<details><summary>問題1</summary>

Next.js 13 App router の middlewareに `console.log` を書いた場合、どこに出力されるでしょうか？



## シンキングタイム

まず、middlewareの役割を思い出してみましょう。middlewareは、ブラウザからのリクエストをサーバーで処理する前に、様々な処理を行うためのものです。つまり、サーバーに到達する前にmiddlewareが処理を実行する必要があります。

次に、`console.log`がどこに出力されるかを考えてみましょう。`console.log`は、ブラウザのコンソール画面に出力されます。しかし、middlewareはサーバーサイドで実行されるため、ブラウザのコンソール画面には出力されません。

つまり、middlewareに`console.log`を書いた場合、サーバーサイドのコンソール画面に出力されます。



middlewareの立ち位置をもう一度考えてください。

middlewareは基本的にブラウザからのリクエストをサーバーで処理する前に、様々な処理を行う検問所みたいな役割を持ちます。

つまり、サーバー到達前にmiddlewareが処理を実行する必要があります。

サーバーに到達する前に処理を実行するのならば console.logはブラウザ側のコンソール画面に出るでしょうか？

どこに出力されるのか、少し考えてみてください。

</details>



<details><summary>回答1</summary>

## 回答

答えはサーバー側です。
Next.js のmiddlewareは単なる Next.js 機能の一つでしかありません。



Next.js 13 App router の全てはサーバーサイドで処理をするようになりました。

では、middlewareに'use client'を付けたらどこで実行されるでしょうか？

これも答えはサーバー側です。

'use client' ディレクティブを付けても付けなくても
middlewareはサーバー側に console.logを出力します。
'use server' ディレクティブを付けても同じです。

App routerやディレクティブなどに関係なくNext.jsではmiddlewareをサーバーサイドの処理として扱っています。

なのでどのように設定しても答えはサーバー側になります。

ただユーザーのリクエストの流れは Next.jsとmiddlewareはそれぞれ独立しています。



</details>



<details><summary>問題2</summary>

↓このように matcher を消したらmiddlewareはどうなるでしょうか？

```
export const config = {};

```

A すべてのパスをmiddlewareがチェックをします。
B すべてのパスはmiddlewareを素通りします。
C Next.jsのアプリケーションの設定に依るので不定である。

## シンキングタイム

何も設定していないのならmiddlewareの機能は働かないのか？
もし、すべてmiddlewareを通るのなら単に負荷がかかるだけではないのか？



</details>

<details><summary>回答2</summary>

答えはすべてのパスをmiddlewareがチェックをします。


<details><summary>問題3＆回答3</summary></details>

~~面倒になったので・・~~ ここからは駆け足で

Q ↓このように matcherを消して、リロードしたらどうなる？

```
export const config = {};

```

A キャッシュが効いているのでmiddlewareは働かない。
B すべてのパスをmiddlewareがチェックをします。 ＜＜＜正解



Q matcherは設定してあるが、配列が空の場合は？

```middleware.ts
export const config = {
  matcher: [],
};

```

A matcherを設定していない時と同じになる。

B ↓root "/" が設定してある場合と同じになる。

```
export const config = {
  matcher: ["/"],
};

```

それにキャッシュは効かないのでconsole.logはリロード毎に表示される。

C root "/" が設定してある場合と同じになる。 ＜＜＜正解
しかし、キャッシュが効いている？ので middlewareは動かない。
(console.logで表示されない。)
※ブラウザをリロードしても console.log は表示されます。



Q matcher の設定を空にする

```
export const config = {
  matcher: [""],
};

```

A matcherを設定していない時と同じになる。

B root "/" が設定してある場合と同じになる。

C root "/" が設定してある場合と同じになる。
それにキャッシュが効いているので middlewareは動かない。
(console.logで表示されない。)

D Error: Invalid middleware found と報告が表示され、エラーになり（開発）サーバーが落ちる。 ＜＜＜正解



</details>



実際に動かしてみます。

```middleware.ts
import { NextRequest, NextResponse } from "next/server";

export function middleware(request: NextRequest) {
  console.log(
    "middleware.ts: request.nextUrl.pathname",
    request.nextUrl.pathname
  );

  return NextResponse.next();
}

export const config = {};

```

↑このコードはmiddlewareに何の処理もさせていません、console.logを表示させているだけです。

ローカルサーバー(npm run dev)を立ち上げるだけで、

```terminal
middleware.ts: request.nextUrl.pathname /
middleware.ts: request.nextUrl.pathname /_next/static/webpack/934f8f934d3a6f9d.webpack.hot-update.json
middleware.ts: request.nextUrl.pathname /
middleware.ts: request.nextUrl.pathname /_next/static/chunks/webpack.js
middleware.ts: request.nextUrl.pathname /_next/static/chunks/react-refresh.js
middleware.ts: request.nextUrl.pathname /_next/static/chunks/main.js
middleware.ts: request.nextUrl.pathname /_next/static/chunks/pages/_app.js
middleware.ts: request.nextUrl.pathname /_next/static/development/_buildManifest.js
middleware.ts: request.nextUrl.pathname /_next/static/development/_ssgManifest.js  
middleware.ts: request.nextUrl.pathname /_next/static/chunks/pages/index.js
middleware.ts: request.nextUrl.pathname /_next/static/development/_devMiddlewareManifest.json
middleware.ts: request.nextUrl.pathname /_next/static/development/_devPagesManifest.json
middleware.ts: request.nextUrl.pathname /favicon.ico

```

このようにmiddlewareを通ってきたことがterminalに出力されています。

ではconfigに "/" ルートだけを設定してみます。

```middleware.ts
export const config = {
  matcher: ["/"],
};

```

ブラウザをリロードすると

```terminal
middleware.ts: request.nextUrl.pathname /

```

middleware はルートだけをチェックしたことがわかります。

middleware はconst config を自動的に読み込まれていることがわかります。
そして主に config には マッチャーが設定されます。



# 1つ目の処理の追加

Next.js 公式サンプル middleware

next.js/examples/middleware at canary · vercel/next.js

https://github.com/vercel/next.js/tree/canary/examples/middleware

middlewareは↓このようになっています。

```middleware.ts
import { NextRequest, NextResponse } from 'next/server'

export function middleware(request: NextRequest) {
  if (request.nextUrl.pathname === '/about') {
    return NextResponse.redirect(new URL('/redirected', request.url))
  }
  if (request.nextUrl.pathname === '/another') {
    return NextResponse.rewrite(new URL('/rewrite', request.url))
  }
  return NextResponse.next()
}

export const config = {
  matcher: ['/about/:path*', '/another/:path*'],
}

```

このサンプルを動かすと
トップページに3つのリンクが表示されます。

## Go to about page (will redirect)

1つの目リンクを押します。
リンクは
http://localhost:3000/about
でしたが、

表示されたページは

http://localhost:3000/redirected

とリダイレクトされました。

ファイルはこのファイルが表示されています。
pages\redirected.tsx



## Go to another page (will rewrite)

2つ目のリンクを押します。

http://localhost:3000/another

↑リンクはanotherで移動した先もanotherでした、

http://localhost:3000/another

しかし表示されたページは

pages\rewrite.tsx
のページが表示されました。


### 解説

このコードは、TypeScriptで書かれたmiddlewareファイルの一部で、`request`オブジェクトの`nextUrl`プロパティの`pathname`プロパティが`"/another"`と等しいかどうかをチェックします。

もし等しい場合、`request`オブジェクトと同じベースURLを持つパスが`/rewrite`の新しいURLオブジェクトを作成し、それを`NextResponse.rewrite()`メソッドに渡します。

このメソッドは、URLを新しいURLに書き換えるようにNext.jsに指示する`NextResponse`オブジェクトを返します。



































































ここより下は、Nexe.js公式ドキュメントの内容と解説です。

# Middlewareとは？

Middleware は、
ユーザーからのリクエストに対して、レスポンスを返す前に、Middlewareで様々な処理を行うことができます。

例えば

* リダイレクト
* リクエスト
* レスポンスを書き換えが出来ます。
* レスポンスのヘッダーを変更出来ます。
* 直接レスポンスを返す事が出来ます。
* 認証済みかどうかを確認して、リクエストを処理するかどうかを決定することができます。
* リクエストに基づいて、レスポンスに対する処理を行うことができます。

このように、middlewareを使用することで、Webアプリケーションの動作をより細かく制御することができます。



# Middlewareを定義する場所

Middleware（Middleware）を定義するには、プロジェクトのルートにある `middleware.ts`（または `.js`）というファイルを使います。例えば、`pages` や `app` と同じレベルに置くか、該当する場合は `src` フォルダの中に置きます。

Middlewareは、Webアプリケーションの動作をより細かく制御することができます。例えば、リクエストやレスポンスを変更したり、リダイレクトしたりすることができます。

以下は、`middleware.ts` ファイルの例です。

```typescript
import { NextResponse } from 'next/server'
import type { NextRequest } from 'next/server'

export function myMiddleware(req: NextRequest) {
  // リクエストに対する処理を行う
  // ...

  // レスポンスを返す
  return NextResponse.next()
}
```

このように、`middleware.ts` ファイルにMiddlewareを定義することで、Webアプリケーションの動作をカスタマイズすることができます。




# Example

```middleware.ts
import { NextResponse } from 'next/server'
import type { NextRequest } from 'next/server'

// middleware関数は、`await`を使用している場合は`async`を付けることができます。
export function middleware(request: NextRequest) {
  return NextResponse.redirect(new URL('/home', request.url))
}

// マッチするリクエストを設定します
export const config = {
  matcher: '/about/:path*',
}

```

このコードは、`/about/:path*`にマッチするリクエストがあった場合に、`/home`にリダイレクトするMiddleware関数を定義しています。

具体的には、`middleware`関数内で、`NextResponse.redirect`メソッドを使用して、リダイレクト先のURLを指定しています。

```
NextResponse.redirect(new URL('/home', request.url))

```

request.urlは、クライアントから送信されたリクエストのURLを表します。つまり、サーバーに送信されたリクエストのURLです。

例
aboutページにアクセスした場合
http://localhost:3000/about?lang=ja
↓
homeページにリダイレクトします。
http://localhost:3000/home?lang=ja

?lang=ja ＜＜この部分はクエリパラメータで
このクエリパラメータ部分は **書き換え後** も維持されています。

このMiddleware関数は、`export`されているため、他のファイルからインポートして使用することができます。また、`config`オブジェクトを定義することで、このMiddleware関数をどのようなリクエストに対して適用するかを設定することができます。



# configオブジェクト

middwareではconfigオブジェクトを設定しておけば、自動的に読み込んでくれます。

例えば、

```
    /*
     * Match all request paths except for the ones starting with:
     * - api (API routes)
     * - _next/static (static files)
     * - _next/image
     * - assets
     * - favicon.ico (favicon file)
     * - sw.js (Service Worker file)
     */
  matcher: ["/((?!api|_next/static|_next/image|assets|favicon.ico|sw.js).*)"]

```



このようにマッチャーを設定しておけば、自動的に読み込んでくれて、このパスにマッチしない（?!（否定先読み）記号を利用しているため）パスに対して処理を行います。



# Matching Paths

Middlewareは、プロジェクト内のすべてのルートに対して起動されます。実行順序は以下の通りです：

1. next.config.jsからのヘッダー
2. next.config.jsからのリダイレクト
3. Middleware（書き換え、リダイレクトなど）
4. next.config.jsからのbeforeFiles（リライト)
5. ファイルシステムのルート（public/、_next/static/、pages/、app/など）
6. afterFiles (next.config.jsから書き換え)
7. 動的ルート (/blog/[slug])
8. fallback（next.config.jsからの書き換え)

Middlewareが実行されるパスを定義するには、2つの方法があります：

fallback は matcher で対応するパスが存在しなかった場合に行う処理です。



## Matcher

matcher を使用すると、特定のパスで実行されるMiddlewareをフィルタリングできます。

一番シンプルな例

```middleware.js
export const config = {
  matcher: '/about/:path*',
}

```



配列で、単一のパスまたは複数のパスにマッチさせることができます。

複数のマッチングが可能

```middleware.js
export const config = {
  matcher: ['/about/:path*', '/dashboard/:path*'],
}

```



matcher configでは正規表現が使用できます。

```middleware.js
    /*
     * Match all request paths except for the ones starting with:
     * - api (API routes)
     * - _next/static (static files)
     * - _next/image (image optimization files)
     * - assets (assets files)
     * - favicon.ico (favicon file)
     * - sw.js (Service Worker file)
     */
export const config = {
  matcher: ["/((?!api|_next/static|_next/image|assets|favicon.ico|sw.js).*)"]
}

```



例えば、`matcher`プロパティには、リクエストに対してマッチするパスを指定することができます。

この例では、`/((?!api|_next/static|_next/image|assets|favicon.ico|sw.js).*)`という正規表現を使用して、

`api`			(API routes)
`_next/static`	(static files)
`_next/image`	(image optimization files)
`assets`		(assets files)
`favicon.ico`	(favicon file)
`sw.js`			(Service Worker file)
これ以外のすべてのリクエストに対してマッチします。



### Tips

マッチャーの値は、ビルド時に静的に解析できるように定数が好ましいです。動的な値は無視されます。



## Configured matchers:

URLパスのマッチングに関するルール

- パスは`/`で始まる必要があります。

- 名前付きパラメータを含むことができます。たとえば、`/about/:path`は`/about/a`と`/about/b`にマッチしますが、`/about/a/c`にはマッチしません。

- 名前付きパラメータには、修飾子を付けることができます。たとえば、`/about/:path*`は、`/about/a/b/c`にもマッチします。`*`は0回以上の繰り返しを表します。`?`は0回または1回の繰り返しを表します。`+`は1回以上の繰り返しを表します。

- 正規表現を使用することができます。たとえば、`/about/(.*)`は、`/about/:path*`と同じように動作します。

これらのルールを使用することで、URLパスに対する柔軟なマッチングを実現することができます。

名前付きパラメータを使用する場合には、パラメータ名が一意であることが必要です。

pillarjs/path-to-regexp: Turn a path string such as `/user/:name` into a regular expression

https://github.com/pillarjs/path-to-regexp#path-to-regexp-1

↑正規表現のルール



Tips

後方互換性のため、Next.jsは常に/publicを/public/indexとみなします。
したがって、/public/:pathのマッチャーはマッチします。



Conditional Statements

```middleware.ts
import { NextResponse } from 'next/server'
import type { NextRequest } from 'next/server'

export function middleware(request: NextRequest) {
  if (request.nextUrl.pathname.startsWith('/about')) {
    return NextResponse.rewrite(new URL('/about-2', request.url))
  }

  if (request.nextUrl.pathname.startsWith('/dashboard')) {
    return NextResponse.rewrite(new URL('/dashboard/user', request.url))
  }
}

```

リクエストに対して条件文で2種類のURLの書き換えを行っています。

具体的には、middleware関数は、requestオブジェクトを受け取り、if文でリクエストされたURLのパスに応じて、URLの書き換えを行っています。

/aboutで始まるパスの場合は、/about-2に書き換え、
/dashboardで始まるパスの場合は、/dashboard/userに書き換えています。

URLの書き換えには、NextResponse.rewriteメソッドを使用しています。

このメソッドは、引数に書き換え後のURLを指定することで、リクエストされたURLを書き換えることができます。



# NextResponse

Next.jsの`NextResponse` APIについて以下のような機能があります。

- リダイレクト：リクエストを別のURLにリダイレクトすることができます。

- レスポンスの書き換え：指定されたURLを表示することで、レスポンスを書き換えることができます。

- リクエストヘッダーの設定：APIルート、getServerSideProps、および書き換え先に対してリクエストヘッダーを設定することができます。

- レスポンスクッキーの設定：レスポンスにクッキーを設定することができます。

- レスポンスヘッダーの設定：レスポンスにヘッダーを設定することができます。

Middlewareからレスポンスを生成する方法としては、以下の2つがあります。

- ルート（ページまたはルートハンドラー）に書き換えて、レスポンスを生成する。

- `NextResponse`オブジェクトを直接返します。
詳細については、ここより↓にある`Producing a Response`を参照してください。



Routing: Pages and Layouts | Next.js

https://nextjs.org/docs/app/building-your-application/routing/pages-and-layouts

Routing: Route Handlers | Next.js

https://nextjs.org/docs/app/building-your-application/routing/route-handlers



# Using Cookies

クッキーは、リクエストのCookieヘッダーまたはレスポンスのSet-Cookieヘッダーに格納されます。

リクエストのCookieヘッダー
クライアントからサーバーに送信されるHTTPリクエストに含まれるヘッダーの一つで、クライアントがサーバーに送信するクッキー情報を含んでいます。

レスポンスのSet-Cookieヘッダー
サーバーからクライアントに送信されるHTTPレスポンスに含まれるヘッダーの一つで、サーバーがクライアントに送信するクッキー情報を含んでいます。

Set-Cookieヘッダーには、クッキーの有効期限、ドメイン、パス、セキュア属性などの情報を含めることができます。

クッキー情報は、名前と値のペアで構成され、Webサイトの訪問履歴やログイン情報などを保存するために使用されます。



Next.jsでは、`NextRequest`と`NextResponse`の拡張機能を使用して、クッキーを簡単にアクセスおよび操作することができます。



```middleware.ts
import { NextResponse } from "next/server"
import type { NextRequest } from "next/server"

export function middleware(request: NextRequest) {
  // "Cookie:nextjs=fast"ヘッダーが受信リクエストに存在すると仮定する
  // RequestCookies APIを使用してリクエストからクッキーを取得する
  let cookie = request.cookies.get("nextjs")
  console.log(cookie) // => { name: 'nextjs', value: 'fast', Path: '/' }
  const allCookies = request.cookies.getAll()
  console.log(allCookies) // => [{ name: 'nextjs', value: 'fast' }]

  request.cookies.has("nextjs") // => true
  request.cookies.delete("nextjs")
  request.cookies.has("nextjs") // => false

  // `ResponseCookies` APIを使用してレスポンスにクッキーを設定する
  const response = NextResponse.next()
  response.cookies.set("vercel", "fast")
  response.cookies.set({
    name: "vercel",
    value: "fast",
    path: "/",
  })
  cookie = response.cookies.get("vercel")
  console.log(cookie) // => { name: 'vercel', value: 'fast', Path: '/' }
  // ja: 出力レスポンスには `Set-Cookie:vercel=fast;path=/test` ヘッダーが含まれます。

  return response
}

```

↑このコードには、
リクエストからクッキーを取得する方法
レスポンスにクッキーを設定する方法
が書かれています。



- リクエストからクッキーを操作する方法は
`request.cookies.get`メソッドを使用して、クッキーの値を取得することができます。
`request.cookies.getAll`メソッドを使用して、すべてのクッキーを取得することができます。
`request.cookies.has`メソッドを使用して、クッキーが存在するかどうかを確認します。
`request.cookies.delete`メソッドを使用して、クッキーを削除します。。



- レスポンスにクッキーを設定する場合は
`response.cookies.set`メソッドを使用して、クッキーを設定します。
また、オブジェクトを渡すことで、複数のクッキーを一度に設定することもできます。
`response.cookies.get`メソッドを使用して、設定されたクッキーの値を取得します。





# Setting Headers

リクエストヘッダとレスポンスヘッダは、NextResponse APIで設定できます。
（リクエストヘッダの設定はNext.js v13.0.0から）



```middleware.ts
import { NextResponse } from "next/server"
import type { NextRequest } from "next/server"

export function middleware(request: NextRequest) {
  // リクエストヘッダーをクローンし、新しいヘッダー `x-hello-from-middleware1` を設定します。
  const requestHeaders = new Headers(request.headers)
  requestHeaders.set("x-hello-from-middleware1", "hello")

  // NextResponse.rewrite でもリクエストヘッダーを設定できます。
  const response = NextResponse.next({
    request: {
      // 新しいリクエストヘッダー
      headers: requestHeaders,
    },
  })

  // 新しいレスポンスヘッダー `x-hello-from-middleware2` を設定します。
  response.headers.set("x-hello-from-middleware2", "hello")
  return response
}

```



↑このコードは、Next.jsでリクエストとレスポンスのヘッダーを設定する方法です。



1. `Headers`オブジェクトを使用して、リクエストヘッダーをクローンし、新しいヘッダーを設定します。`request.headers`からヘッダーを取得し、`requestHeaders.set`メソッドを使用して、新しいヘッダーを設定します。

2. `NextResponse.next`メソッドを使用して、新しいレスポンスを作成します。このとき、`request`オプションを使用して、新しいリクエストヘッダーを設定することができます。`requestHeaders`を使用して、新しいヘッダーを設定します。

3. `response.headers.set`メソッドを使用して、新しいレスポンスヘッダーを設定します。
クローン
オブジェクトをクローンするとは、元のオブジェクトと同じプロパティを持つ新しいオブジェクトを作成することです。
元のオブジェクトと新しいオブジェクトは、別々のメモリ領域に保存されます。
クローンすることで、元のオブジェクトを変更しても、新しいオブジェクトには影響がなくなります。

このコードでは、`Headers`オブジェクトをクローンして、新しいヘッダーを設定しています。`Headers`オブジェクトは、HTTPリクエストやレスポンスのヘッダーを表すオブジェクトです。
`Headers`オブジェクトをクローンすることで、元のリクエストヘッダーを変更することなく、新しいヘッダーを設定することができます。

注意点としては、ヘッダーのサイズが大きすぎる場合、バックエンドのWebサーバーの設定によっては、431 Request Header Fields Too Largeエラーが発生する可能性があることです。また、ヘッダーにはセキュリティ上の問題があるため、機密情報を含めないようにする必要があります。

この方法の長所は、リクエストとレスポンスのヘッダーを柔軟に設定できることです。

例えば、認証トークンをリクエストヘッダーに設定することで、APIの認証を行うことができます。
また、レスポンスヘッダーには、キャッシュ制御やセキュリティ関連の情報を設定することができます。

この方法は、APIの認証やキャッシュ制御、セキュリティ関連の情報を設定する場合に使用することができます。
また、リクエストとレスポンスのヘッダーを柔軟に設定することができるため、様々な用途に応用することができます。

※バックエンドのウェブサーバーの設定によっては、431 Request Header Fields Too Large エラーが発生する可能性があります。



# Producing a Response

ResponseまたはNextResponseインスタンスを返すことで、Middlewareから直接応答できます。(これはNext.js v13.1.0から利用可能です。)



```middleware.ts
import { NextRequest, NextResponse } from 'next/server'
import { isAuthenticated } from '@lib/auth'

// Limit the middleware to paths starting with `/api/`
export const config = {
  matcher: '/api/:function*',

}

export function middleware(request: NextRequest) {

  // Call our authentication function to check the request

  if (!isAuthenticated(request)) {

    // Respond with JSON indicating an error message

    return new NextResponse(
      JSON.stringify({ success: false, message: 'authentication failed' }),
      { status: 401, headers: { 'content-type': 'application/json' } }
    )
  }
}

```



↑このコードは、Next.jsでMiddlewareから直接レスポンスを返す方法です。

1. `config`オブジェクトを使用して、Middlewareを`/api/`で始まるパスに制限します。
これにより、このMiddlewareは`/api/`で始まるパスにのみ適用されます。

2. `isAuthenticated`関数を使用して、リクエストが認証されているかどうかを確認します。
認証に失敗した場合は、エラーメッセージを含むJSONレスポンスを返します。

3. `NextResponse`クラスを使用して、新しいレスポンスを作成します。
`NextResponse`クラスは、`body`と`options`の2つの引数を受け取ります。

`body`はレスポンスの本文を表します。
`options`はレスポンスのオプションを表します。

このコードでは、`body`にJSON文字列を、`options`にステータスコードとヘッダーを設定しています。

この方法の長所は、Middlewareから直接レスポンスを返すことができるため、APIの認証やエラーハンドリングなど、様々な用途に応用することができます。

また、`NextResponse`クラスを使用することで、レスポンスの本文やヘッダーを柔軟に設定することができます。

一方、短所としては、レスポンスを直接返すため、後続のMiddlewareやハンドラーが実行されないことがあることが挙げられます。また、レスポンスの本文やヘッダーを直接設定するため、コードが複雑になる可能性があることもあります。

この方法は、APIの認証やエラーハンドリングなど、Middlewareから直接レスポンスを返す必要がある場合に使用することができます。また、`NextResponse`クラスを使用することで、レスポンスの本文やヘッダーを柔軟に設定することができます。



# Advanced Middleware Flags

Next.jsのv13.1では、高度なユースケースに対応するために、

skipTrailingSlashRedirect
skipMiddlewareUrlNormalize

という2つの追加フラグがMiddlewareに導入されました。

これにより、直接アクセスとクライアント側の遷移を同じように扱うことができない場合に、元のURLを使用することができます。



## skipTrailingSlashRedirect

Next.jsのデフォルトのリダイレクトを無効にして、末尾のスラッシュを追加または削除します。

※トレーリングスラッシュ
URLの末尾に付くスラッシュのことです。
例えば、`https://example.com/path/`のように、末尾にスラッシュが付いている場合があります。
トレーリングスラッシュが付いているかどうかによって、同じページでも異なるURLとして扱われることがあります。



```next.config.js
module.exports = {
  skipTrailingSlashRedirect: true,
}

```

```middleware.js
const legacyPrefixes = ['/docs', '/blog']

export default async function middleware(req) {
  const { pathname } = req.nextUrl

  if (legacyPrefixes.some((prefix) => pathname.startsWith(prefix))) {
    return NextResponse.next()
  }

  // apply trailing slash handling
  if (
    !pathname.endsWith('/') &&
    !pathname.match(/((?!\.well-known(?:\/.*)?)(?:[^/]+\/)*[^/]+\.\w+)/)
  ) {
    req.nextUrl.pathname += '/'
    return NextResponse.redirect(req.nextUrl)
  }
}

```

↑このコードは、Next.jsのMiddlewareを使用して、トレーリングスラッシュの処理をカスタマイズする方法を示しています。

1. `skipTrailingSlashRedirect`フラグを使用して、Next.jsのデフォルトのリダイレクトを無効にします。
これにより、Middleware内でカスタムな処理を行うことができます。例えば、一部のパスにはトレーリングスラッシュを付け、他のパスには付けないようにすることができます。これにより、徐々に移行することができます。

2. `middleware`関数を定義し、`req`オブジェクトから`pathname`を取得します。

3. `legacyPrefixes`配列に含まれるパスの場合は、`NextResponse.next()`を返して、後続のMiddlewareやハンドラーが実行されるようにします。

4. トレーリングスラッシュの処理を行います。`pathname`がスラッシュで終わっていない場合、かつ`.well-known`で始まるパスでない場合は、`req.nextUrl.pathname`にスラッシュを追加して、`NextResponse.redirect()`を返します。これにより、トレーリングスラッシュが付いたURLにリダイレクトされます。

この方法の長所は、Middlewareでより柔軟なトレーリングスラッシュの処理を行うことができることです。例えば、一部のパスにはトレーリングスラッシュを付け、他のパスには付けないようにすることができます。

また、`skipTrailingSlashRedirect`フラグを使用することで、Next.jsのデフォルトの挙動から外れることができます。

一方、短所としては、トレーリングスラッシュの処理をカスタマイズするため、コードが複雑になる可能性があることが挙げられます。

この方法は、トレーリングスラッシュの処理をカスタマイズする必要がある場合に使用することができます。例えば、一部のパスにはトレーリングスラッシュを付け、他のパスには付けないようにすることができます。また、`skipTrailingSlashRedirect`フラグを使用することで、Next.jsのデフォルトの挙動から外れることができます。ただし、トレーリングスラッシュの処理をカスタマイズする場合は、コードが複雑になる可能性があることに注意する必要があります。



## skipMiddlewareUrlNormalize

Next.jsが行うURL正規化を無効にし、直接訪問とクライアント遷移の処理を同じにします。
元のURLを使用して完全に制御する必要がある高度なケースもありますが、そのような場合はこの機能を利用できます。


```next.config.js
module.exports = {
  skipMiddlewareUrlNormalize: true,
}

```



```middleware.js
export default async function middleware(req) {
  const { pathname } = req.nextUrl

  // GET /_next/data/build-id/hello.json

  console.log(pathname)
  // with the flag this now /_next/data/build-id/hello.json
  // without the flag this would be normalized to /hello
}

```



↑このコードは、Next.jsのMiddlewareを使用して、URLの正規化処理をカスタマイズする方法です。

1. `skipMiddlewareUrlNormalize`フラグを使用して、Next.jsがURLを正規化する処理を無効にします。
これにより、直接アクセスとクライアント側の遷移を同じように扱うことができない場合に、元のURLを使用することができます。

2. `middleware`関数を定義し、`req`オブジェクトから`pathname`を取得します。

3. `console.log()`を使用して、`pathname`を出力します。
`skipMiddlewareUrlNormalize`フラグを使用している場合、`pathname`は正規化されずにそのまま出力されます。
一方、フラグを使用していない場合は、`pathname`が正規化されてしまい、元のURLと異なる場合があります。

この方法の長所は、URLの正規化処理をカスタマイズすることができることです。
例えば、直接アクセスとクライアント側の遷移を同じように扱うことができない場合に、元のURLを使用することができます。

一方、短所としては、フラグを使用することで、Next.jsのデフォルトの挙動から外れるため、予期しない動作を引き起こす可能性があることが挙げられます。
また、フラグを使用することで、コードが複雑になる可能性があることもあります。

この方法は、URLの正規化処理をカスタマイズする必要がある場合に使用することができます。ただし、フラグを使用する場合は、予期しない動作に注意する必要があります。


# version

| Version | Changes |
|---------|---------|
| v13.1.0 | Advanced Middleware flags added |
| v13.0.0 | Middleware can modify request headers, response headers, and send responses |
| v12.2.0 | Middleware is stable, please see the upgrade guide |
| v12.0.9 | Enforce absolute URLs in Edge Runtime (PR) |
| v12.0.0 | Middleware (Beta) added |

v13.0.0
Middlewareはリクエスト ヘッダー、レスポンス ヘッダーを変更し、レスポンスを送信できます。



疑問

複数のmiddlewareファイルに分けられないのか？





# 参考

Next.jsで複数のmiddlewareの関数を連結させる

https://zenn.dev/hayato94087/articles/8f6496e0b8936f


