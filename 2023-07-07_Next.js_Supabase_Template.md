<!--
title:   Next.js app router 開発用テンプレート (Storybook Supabase shadcn/ui)
tags:    AppRouter,Next.js,Supabase,shadcn,storybook
id:      3ad7a1564d2b6c56d4db
private: false
-->

# 開発環境
Windows 10
VSCode
Next.js 13 app router
Supabase
shadcn/ui
Storybook
Vercel


# インストール

新しいインストール場所で

## ソースのダウンロード

`gh repo clone masakinihirota/next13apptemplate`

or

`git clone https://github.com/masakinihirota/next13apptemplate.git`

`cd next13apptemplate`

## pnpmでインストール

`pnpm add -g pnpm`

`pnpm i`

`pnpm run dev`




# この記事の趣旨

このリポジトリは既存のツールを組み合わせているだけなので何の機能もありません。
だからサンプルやデモではなくテンプレートです。

ただ、現在、複数の機能をまとめるだけでも微妙な設定変更が必要で、それには多くの調査が必要になるためここにテンプレートとして記録に残しておきます。

# 開発用テンプレート

Next.jsと関連するツールをインストールしてNext.jsアプリ開発のテンプレートとして利用します。

# テンプレートのリポジトリ

https://github.com/masakinihirota/next13apptemplate


↑このテンプレートは↓を順にたどっていくと↑のリポジトリと同じになります。

# 開発中の確認＆ダッシュボード

Next.js

http://localhost:3000

Storybook

http://localhost:6006/

ローカルのSupabase

http://localhost:54323/projects

サーバーのSupabase

https://app.supabase.com/projects

Vercel

https://vercel.com/dashboard

----------------------------------------

# 便利サイト、チートシート

Tailwind CSS Cheat Sheet

https://tailwindcomponents.com/cheatsheet/



----------------------------------------

# 重要コマンド
よく使うコマンドや便利ツール等

```
Supabase CLI 更新
scoop update supabase

Next.jsローカルサーバーを起動
npm run dev

storybookを起動
npm run storybook

supabase start
supabase stop
supabase db reset
supabase status

Supabase ダッシュボード
http://localhost:54323

ストーリーブック
pnpm run storybook

インタラクションテスト (storybookを起動させて)
pnpm run test-storybook

Vercel
pnpm vercel login
pnpm vercel link
pnpm vercel env pull

インストール時から一定期間後に別ブランチを立てて実行
update可能なパッケージ一覧を取得
pnpm outdated

pnpm update

インストール
pnpm install -g npm-check-updates
npm-check-updates

ncu

全て最新バージョンにアップデートしたい場合は
ncu -u




開発ブランチのマージ

git checkout main
git merge -
※ - 記号は直前にチェックアウトしたブランチを指定してマージします。



```

# 作業コマンド

開発のサイクルとして、作業ブランチを作り、そこでコードを書いてテストして、その後にコミットしたらmainブランチに移動後マージします。(これを繰り繰り返します。)

作業ブランチの作成
git checkout -b <branch-name>

※作業します。

mainブランチに移動
git checkout main

ブランチのマージ
直前にいたブランチのマージ
git merge -

（不要になった）ブランチの削除
git branch -d <branch-name>



----------------------------------------

Next.js 13 app router テンプレートの作成

# リポジトリ名

next13apptemplate



# テンプレートの作成

Next.js をインストール

<details><summary>インストールするその他のツール(長い)</summary>

(未)＝未インストール＆インストール候補

※ 重要なのは必要になった時に調べてインストールする。
一気に全部入れても混乱するだけで使いこなせません。

Next.js by Vercel - The React Framework

https://nextjs.org/

TypeScript: JavaScript With Syntax For Types.

https://www.typescriptlang.org/

Tailwind CSS - Rapidly build modern websites without ever leaving your HTML.

https://tailwindcss.com/

Find and fix problems in your JavaScript code - ESLint - Pluggable JavaScript Linter

https://eslint.org/

Prettier · Opinionated Code Formatter

https://prettier.io/

The Open Source Firebase Alternative | Supabase

https://supabase.com/

Storybook: Frontend workshop for UI development

https://storybook.js.org/

GitHub Japan | GitHub

https://github.co.jp/

Vercel

https://vercel.com/

(未) tRPC - Move Fast and Break Nothing. End-to-end typesafe APIs made easy. | tRPC

https://trpc.io/

tRPCは App router 未対応です。

[tRPC App router 対応状況](https://github.com/trpc/trpc/issues/3297)

## テスト関連

(未) Vitest | A blazing fast unit test framework powered by Vite

https://vitest.dev/

サンプル
next.js/examples/with-vitest at canary · vercel/next.js · GitHub

https://github.com/vercel/next.js/tree/canary/examples/with-vitest

(未) Chromatic: Storybook deployment, review, and test

https://www.chromatic.com/

(未) Testing Library | Testing Library

https://testing-library.com/

(未) JavaScript Component Testing and E2E Testing Framework | Cypress

https://www.cypress.io/

(未) Fast and reliable end-to-end testing for modern web apps | Playwright

https://playwright.dev/

(未) Jest · 🃏 Delightful JavaScript Testing

https://jestjs.io/ja/



## i18n 国際化

(未) react-i18next

Introduction - react-i18next documentation

https://react.i18next.com/

サンプル
next.js/examples/app-dir-i18n-routing at canary · vercel/next.js · GitHub

https://github.com/vercel/next.js/tree/canary/examples/app-dir-i18n-routing



# 他のインストール候補

## UI ＆  CSS

### Next.jsの app routerに対応している UI コンポーネント集

shadcn/ui

https://ui.shadcn.com/

Next.js - shadcn/ui

https://ui.shadcn.com/docs/installation/next

ReactのUIコンポーネントなら@shadcn/uiがちょうどいい

https://zenn.dev/mottox2/articles/react-shadcn-ui



(未) Kuma UI

https://www.kuma-ui.com/

(未) Mantine next example

https://v7.mantine.dev/

Can I use Mantine with Next.js app dir?
Currently, it is not recommended, we are working on new major version that will resolve all of the current issues related to server side rendering.

>MantineをNext.js app dirで使用できますか？
サーバーサイドレンダリングに関する現在の問題をすべて解決する新しいメジャーバージョンを開発中です。

このversion7が開発中です。

### Next.jsの app routerに対応している CSS

(未) vanilla-extract — Zero-runtime Stylesheets-in-TypeScript.

https://vanilla-extract.style/

CSS・TypeScriptの相性が抜群。vanilla-extractが最高のCSS開発体験をくれた

https://zenn.dev/moneyforward/articles/vanilla-extract



## デザイン

Figma

https://www.figma.com/



## 開発時の利用ツール

DB関連
SQLクライアント

DBeaver Community

https://dbeaver.io/download/

TablePlus | Modern, Native Tool for Database Management

https://tableplus.com/download

A5:SQL Mk-2 - フリーのSQLクライアント/ER図作成ソフト (松原正和)

https://a5m2.mmatsubara.com/



# その他

(未) Zod | Documentation

https://zod.dev/

(未) Prisma | Next-generation ORM for Node.js & TypeScript

https://www.prisma.io/



</details>



# ルール

書いたコードはsrcフォルダ以下に移動する
src/

共通のstyleコード
src/styles



ブランチは基本2種類
mainブランチ 公開用のコード
必要に応じて開発用のブランチを作成(ここで開発をする)
この２つを軸に開発していく
一区切りついたら開発用のブランチをmainにマージしていく



## 開発手法

コロケーション

コロケーションとは、
関連するコードを近くに配置することで、
コードの理解性を向上させる設計パターンの一つです。
コロケーションパターンともいいます。

コロケーションパターンを採用することで
リマインド効果がある
半年前の自分は別人理論
コードを読みやすくする

一つのフォルダの中に一つのコンポーネント単位を置く
コンポーネントは複数のコンポーネントで成り立っておい
一つはデータコンポーネント
一つは表示コンポーネント
をつかう
テストファイルと
Storyファイルも一緒に
コンポーネントフォルダのrootに置く

コロケーション | makotot.dev ファイルの配置

https://www.makotot.dev/posts/colocation-translation-ja

インタラクションテスト
ストーリーとテストを一元管理できる
ストーリーファイルにテストを記述する事になるため、
ストーリーとテストを一元管理できます。

テストを実行する方法は主に2つで、
通常はブラウザ上でStorybookを
表示して実行します。

テストランナーをセットアップすることで、
CLIでの実行が可能になります。



# ディレクトリ構成

```tree
src
├── app
│   ├── layout.tsx
│   └── page.tsx
├── components
│   ├── ui
│   │   ├── alert-dialog.tsx
│   │   ├── button.tsx
│   │   ├── dropdown-menu.tsx
│   │   └── ...
│   ├── main-nav.tsx
│   ├── page-header.tsx
│   └── ...
├── lib
│   └── utils.ts
├── styles
│   └── globals.css
├── next.config.js
├── package.json
├── postcss.config.js
├── tailwind.config.js
└── tsconfig.json



```

参考
Next.js - shadcn/ui

https://ui.shadcn.com/docs/installation/next



----------------------------------------

# インストール

## Next.jsをインストール

pnpm create-next-app@latest

√ What is your project named? ... vns
√ Would you like to use TypeScript? ... No / Yes
√ Would you like to use ESLint? ... No / Yes
√ Would you like to use Tailwind CSS? ... No / Yes
√ Would you like to use `src/` directory? ... No / Yes
√ Would you like to use App Router? (recommended) ... No / Yes
√ Would you like to customize the default import alias? ... No / Yes
√ What import alias would you like configured? ... @/*



.eslintrc.json(初期)

```.eslintrc.json
{
  "extends": "next/core-web-vitals"
}

```



## TailwindCSS

https://nextjs.org/docs/app/building-your-application/styling/tailwind-css

src\app\globals.css
このファイルの配置を
src\styles\globals.css
へ移動します。

コマンド
New-Item -ItemType Directory -Path "src\styles"
Move-Item -Path "src\app\globals.css" -Destination "src\styles\globals.css"


globals.cssファイルから、デフォルトのインストール画面で必要だったCSS部分を削除し、TailwindCSSで必要な部分だけを残します。

```src\styles\globals.css
@tailwind base;
@tailwind components;
@tailwind utilities;

```



globals.cssファイルを読み込んでいるファイルのpathを修正します。

```src\app\layout.tsx
import '@/styles/globals.css'

...

<html lang='ja'>

```

日本語にも直しておきます。



## Storybookのインストール

pnpm storybook@latest init


TailwindCSSをStorybookでも適用されるように設定します。

```.storybook/preview.ts
import "../src/styles/globals.css"

```



----------------------------------------

## eslint


Next.jsとStorybookをインストールした直後のeslintの設定

```.eslintrc.json
{
  "extends": [
    "next/core-web-vitals",
    "plugin:storybook/recommended"
  ]
}

```

next.js/packages/eslint-config-next/index.js at canary · vercel/next.js · GitHub

https://github.com/vercel/next.js/blob/canary/packages/eslint-config-next/index.js

上記コードを調べるとnext/core-web-vitalsは
react/recommended
react-hooks/recommended
next/recommended
を読み込んでいるので、これらのインストールは不要です。



### .eslintignoreファイルの作成

touch .eslintignore

lintから外したいファイルを設定します。

```.eslintignore
# config
.eslintrc.js
.prettierrc
next.config.js
tailwind.config.js
tsconfig.json
postcss.config.js

# build dir
build/
bin/
obj/
out/
.next/

# Storybook
*.stories.ts
*.stories.tsx

```



# prettier

Install Prettier

https://prettier.io/docs/en/install.html

pnpm add --save-dev --save-exact prettier

空の.prettierrcを作成して、Prettierを使用していることをエディターやその他のツールに知らせます。

```.prettierrc


```



.eslintrc.jsonにprettier設定の追加をします。

```.eslintrc.json
{
  "extends": [
    "next/core-web-vitals",
    "plugin:storybook/recommended",
    "prettier"
  ]
}

```



package.jsonにscriptを追加します。

```package.json

	"format": "prettier --write app/"

```

※ app/ フォルダ以下をフォーマットします。

## .prettierrc 設定ファイルの追加

.prettierrcファイルを作成します。

```.prettierrc
{
  "tabWidth": 2,
  "useTabs": false
}

```



次に、.prettierignore ファイルを作成して、どのファイルをフォーマットしないかを Prettier CLI とエディターに知らせます。

touch .prettierignore

```.prettierignore
# Ignore artifacts:
build
coverage

# dotfile
.env*

# markdown
*.md

# next.js
/.next/
/out/

# production
/build

package-lock.json

*.stories.ts
*.stories.tsx


```



動作確認のため
prettierを実行します。
pnpm run format

巨大プロジェクトの場合に時間短縮のためフォルダを指定したい場合
prettier --write [フォルダ名]

直接ファイルを指定する場合
prettier --write app/components/Button.js

globを使用してtestファイルだけ指定する場合
prettier --write "app/**/*.test.js"

prettierが実行されているかの確認（上書きはしない）
pnpm prettier . --check





eslintで必要なプラグインを設定します。

javascriptのlint設定がないので
eslint:recommended
を入れます。


```.eslintrc.json
{
  "extends": [
    "eslint:recommended",
    "next/core-web-vitals",
    "plugin:storybook/recommended",
    "prettier"
  ]
}

```



pnpm i -D @typescript-eslint/parser

pnpm i -D @typescript-eslint/eslint-plugin

```.eslintric.js
{
  "extends": [
    "eslint:recommended",
    "plugin:@typescript-eslint/recommended",
    "plugin:@typescript-eslint/recommended-requiring-type-checking",
    "next/core-web-vitals",
    "plugin:storybook/recommended",
    "prettier"
  ],
  "parser": "@typescript-eslint/parser",
  "parserOptions":  {
    "project": "./tsconfig.json"
  },
  "plugins": [
    "@typescript-eslint"
  ],
  "root": true
}

```


便利プラグインを追加します。
tailwindcssを並べ替えします。

prettier-plugin-tailwindcss


npm install -D prettier-plugin-tailwindcss

インストールしても自動化されない環境もあります。
その場合は設定に書き込みます。


```prettier.config.js
/** @type {import('prettier').Config} */
module.exports = {
    "plugins": [require('prettier-plugin-tailwindcss')],
    "semi": false,
    "singleQuote": true,
    "printWidth": 80,
    "tabWidth": 2,
    "trailingComma": "all",
    "jsxSingleQuote": true
  }

```



# eslint-plugin-import

Next.js開発 ESLintでimport文の自動挿入、自動削除、自動ソート - Qiita

https://qiita.com/masakinihirota/items/fae505a58892b00550a7

npm install --save-dev eslint-plugin-import eslint-plugin-unused-imports

```.eslintrc.json (最終形)
{
  "env": {
    // Node.jsのランタイム環境の一部です。
    "node": true,
    // 最新のJavaScriptの機能を有効にするための設定です。
    "es2022": true
  },
  "extends": [
    "eslint:recommended",
    "plugin:@typescript-eslint/recommended",
    "plugin:@typescript-eslint/recommended-requiring-type-checking",
    "next/core-web-vitals",
    "plugin:storybook/recommended",
    "prettier"
  ],
  // ESLintが使用するパーサーを指定します。この例では、@typescript-eslint/parserを指定しています。
  "parser": "@typescript-eslint/parser",
  "parserOptions": {
    "project": "./tsconfig.json"
  },
  "plugins": ["@typescript-eslint", "import", "unused-imports"],
  // ESLintが設定ファイルを探しに行く際に、ルートディレクトリから探索を開始するかどうかを指定します。
  "root": true,
  "rules": {
    // TypeScriptで未使用の変数を許可するかどうかを指定します。この例では、offに設定されているため、未使用の変数を許可します。
    "@typescript-eslint/no-unused-vars": "off",
    // 未使用のインポートに関するルールを指定します。この例では、warnに設定されているため、未使用のインポートがある場合に警告を出します。
    "unused-imports/no-unused-imports": "warn",
    // モジュールのインポート順序に関するルールを指定します。この例では、配列の中に複数のグループが定義されています。各グループは、groupsプロパティで定義されています。
    "import/order": [
      "error",
      {
        "groups": [
          // builtin: Node.js に組み込まれているモジュール
          // external: pnpm install 等 プロジェクト外部からインストールされたモジュール
          // internal: プロジェクト内のモジュールで、パスを指定してインポートされたもの
          // parent: 親モジュール 相対パスを使用してインポートされたもの
          // sibling: 兄弟モジュール 相対パスを使用してインポートされたもの
          // index: インデックスファイルで、相対パスを使用してインポートされたもの
          // object: オブジェクトファイルで、相対パスを使用してインポートされたもの
          // type: 型ファイルで、相対パスを使用してインポートされたもの
          "builtin",
          "external",
          "internal",
          ["parent", "sibling"],
          "index",
          "object",
          "type"
        ],
        // それぞれのgroupsとの間は1行分空けます。
        "newlines-between": "always",
        // 特定のグループの import 文を除外するかどうかを指定します。
        "pathGroupsExcludedImportTypes": ["builtin", "external"],
        // order オプションは、アルファベット順にします。
        // caseInsensitive オプションは、大文字小文字を無視してアルファベット順に並べるかどうかを指定します。
        "alphabetize": { "order": "asc", "caseInsensitive": true },
        "pathGroups": [
          // pattern: インポートパスのパターンを指定します。この例では、src/ディレクトリ以下のすべてのファイルを指定しています。
          // group: インポートパスが一致した場合に、どのグループに属するかを指定します。この例では、internalグループに属するように指定しています。
          // position: インポートパスが一致した場合に、どの位置に挿入するかを指定します。この例では、beforeに指定しているため、他のグループよりも前に挿入されます。
          { "pattern": "src/**", "group": "internal", "position": "before" }
        ]
      }
    ]
  }
}

```


## 確認用のページ

import文の自動削除や自動挿入が試せます。

```src\app\page.tsx
import { type NextPage } from "next"
import Link from "next/link"

const Home: NextPage = () => {
  // const hello = api.example.hello.useQuery({ text: "from tRPC" });

  return (
    <main>
      <h1>VNS.BLUE</h1>
      Next.js app router 開発用テンプレート (Storybook Supabase shadcn/ui)
      <br />
      {/* ↓この行を消したり復元したりするとimport文が自動削除、自動挿入されるのが確認できます。 */}
      <Link href='/'>Home</Link>
    </main>
  )
}

export default Home

```


## VSCodeの設定

VSCodeの設定ファイルを開いて追記します。

```setting.json
  // TypeScript JavaScript
  // インポート文の、自動挿入、自動削除、自動ソート
  "editor.codeActionsOnSave": {
    // import文を自動で探して挿入する。
    "source.addMissingImports": true,
    // 保存時にeslintを実行
    "source.fixAll.eslint": true
  },

```





# コミット時にコードの検証と自動整形をします。

huskyを入れてcommit時にlint --fixが走るようにします。

npm install --save-dev husky lint-staged
pnpm husky install
npm pkg set scripts.prepare="husky install"
pnpm husky add .husky/pre-commit "pnpm lint-staged"

※このlint-stagedの設定ではnextjsでlintを実行するとエラーが起きてしまします。



touch .lintstagedrc.js


```.lintstagedrc.js
const path = require('path')

const buildEslintCommand = (filenames) =>
  `next lint --fix --file ${filenames
    .map((f) => path.relative(process.cwd(), f))
    .join(' --file ')}`

module.exports = {
  '*.{ts,tsx}': [
        () => 'tsc --incremental false --noEmit',
        buildEslintCommand,
        "prettier --write"
    ],
}

```


この設定をすると
{.ts,.tsx}ファイルに対してnext lintと prettier
をコミット時に行ってくれます。





huskyの確認

git config --local core.hooksPath
> .husky

git config --local core.hooksPath は、Gitのローカルリポジトリに対して、Gitフックスクリプトのパスを設定するコマンドです。

Gitフックスクリプトは、Gitの特定のイベントが発生したときに自動的に実行されるスクリプトです。例えば、コミットをする前にコードのフォーマットを自動的に修正するスクリプトを実行することができます。


huskyが設定してあると *.stories.tsx ファイルをコミットしようとすると TypeScriptでのコンパイルエラーになります。

そこで*.stories.tsx ファイルをコンパイル時に除外するように設定します。

```tsconfig.json
{
  "compilerOptions": {
    "target": "es5",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "node",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  // huskeyでは、sotriesファイルでTypeScriptコンパイルエラーが出るので除外する。
  "exclude": ["node_modules", "**/*.stories.ts"]
}

```


----------------------------------------

# shadcn/ui

Next.js - shadcn/ui

https://ui.shadcn.com/docs/installation/next

ReactのUIコンポーネントなら@shadcn/uiがちょうどいい

https://zenn.dev/mottox2/articles/react-shadcn-ui

コンポーネントはCLIからインストールする方法と
サイトからコードをコピーするやり方があります。



shadcn/ui公式の推奨 Next.jsアプリの構成

```tree
src
├── app
│   ├── layout.tsx
│   └── page.tsx
├── components
│   ├── ui
│   │   ├── alert-dialog.tsx
│   │   ├── button.tsx
│   │   ├── dropdown-menu.tsx
│   │   └── ...
│   ├── main-nav.tsx
│   ├── page-header.tsx
│   └── ...
├── lib
│   └── utils.ts
├── styles
│   └── globals.css
├── next.config.js
├── package.json
├── postcss.config.js
├── tailwind.config.js
└── tsconfig.json

```



セットアップ 初期化

UIの保存フォルダを作っておきます
src/components/ui


pnpm shadcn-ui@latest init

```
> pnpm shadcn-ui@latest init
√ Would you like to use TypeScript (recommended)? ... no / yes
√ Which style would you like to use? » New York
√ Which color would you like to use as base color? » Slate
√ Where is your global CSS file? ... src/styles/globals.css
√ Would you like to use CSS variables for colors? ... no / yes
√ Where is your tailwind.config.js located? ... tailwind.config.js
√ Configure the import alias for components: ... @/components
√ Configure the import alias for utils: ... @/lib/utils
√ Are you using React Server Components? ... no / yes
√ Write configuration to components.json. Proceed? ... yes

✔ Writing components.json...
✔ Initializing project...
✔ Installing dependencies...

Success! Project initialization completed.

```


ヘルプコマンド
pnpm @shadcn/ui

CLIからのインストール方法
pnpm @shadcn/ui add

インストールするコンポーネントを選択します。
Aですべてを選択します。
※すべて選択してインストールするとエラーになった

インストール先を指定します。
src/components/ui

※注意：すでに同じコンポーネント名が存在すると上書きされます。



## お試し

buttonコンポーネントをインストールしてみます。

pnpm @shadcn/ui add

buttonを選択します。

インストール先を指定します。



動作確認用

```src\app\page.tsx
import { Button } from '@/components/ui/button'

export default function Home() {
  return (
    <main>
      <Button>Button</Button>
    </main>
  )
}

```



----------------------------------------

# Storybookの動作確認

npm run storybook

Storybook
http://localhost:6006/

コロケーションパターンで開発するので、
コンポーネントファイルと
ストーリーファイル(SF3)と
テストファイルを同一フォルダ内に入れます。

現在はデフォルトのコンポーネントがstoriesフォルダに入っています。


## Storybookインタラクションテストの組み込み

Play function

https://storybook.js.org/docs/react/writing-stories/play-function


npm install @storybook/testing-library @storybook/jest @storybook/addon-interactions --save-dev

Storybookの「インタラクションテスト」でフロントエンドのテストをシンプルに管理する！｜SHIFT Group 技術ブログ

https://note.com/shift_tech/n/n5646b52b3092


インタラクションテストに対応した
コンポーネントと
ストーリーを作成します。



```Button.tsx
import React, { useState } from "react";
import { useRouter } from "next/router";
import "./button.css";

interface ButtonProps {
  testId: string;
  label: string;
  text?: string;
  href?: string;
  primary?: boolean;
  "data-testid"?: string;
}

export const Button = ({
  testId,
  label,
  text,
  href,
  primary = false,
  ...props
}: ButtonProps) => {
  const [textToggle, setTextToggle] = useState(false);
  const router = useRouter();
  const mode = primary ? "primary" : "";

  const onClick = () => {
    if (href) {
      router.push(href);
    } else {
      setTextToggle(!textToggle);
    }
  };

  return (
    <div>
      <button
        data-test-id={testId}
        type="button"
        className={["button", mode].join(" ")}
        onClick={onClick}
        {...props}
      >
        {　label　}
      </button>
      {textToggle && <div>{text}</div>}
    </div>
  );
};

```



```button.css
.button {
  font-family: "Nunito Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
  font-size: 20px;
  font-weight: 700;
  border: 0;
  border-radius: 3em;
  cursor: pointer;
  display: inline-block;
  line-height: 1;
  padding: 10px 20px;
  color: #333;
  background-color: transparent;
  box-shadow: rgba(0, 0, 0, 0.15) 0px 0px 0px 1px inset;
}
.primary {
  color: white;
  background-color: #1ea7fd;
}

```


```Button.stories.ts
import type { Meta, StoryObj } from "@storybook/react";
import { within, userEvent } from "@storybook/testing-library";
import { jest, expect } from "@storybook/jest";

import { Button } from "./Button";

const fn = jest.fn();

const meta: Meta<typeof Button> = {
  title: "Atoms/Button",
  component: Button,
  tags: ["autodocs"],
  parameters: {
    nextjs: {
      router: {
        push: fn,
      },
    },
  },
};

export default meta;
type Story = StoryObj<typeof Button>;

export const Default: Story = {
  args: {
    label: "Default",
    "data-testid": "button",
  },
  play: async ({ canvasElement, step }) => {
    const canvas = within(canvasElement);

    await step("ボタンにLabelの文字列が表示されている", async () => {
      await expect(canvas.getByText("Default")).toBeInTheDocument();
    });
  },
};

export const Primary: Story = {
  args: {
    primary: true,
    label: "Primary",
    "data-testid": "button",
  },
  play: async ({ canvasElement, step }) => {
    const canvas = within(canvasElement);

    await step("ボタンのclassName属性にprimaryが適用されている", async () => {
      const button = canvas.getByTestId("button");
      await expect(button.classList.contains("primary")).toBe(true);
    });
  },
};

export const Toggle: Story = {
  args: {
    label: "Toggle",
    text: "Success",
    "data-testid": "button",
  },
  play: async ({ canvasElement, step }) => {
    const canvas = within(canvasElement);

    await step("ボタン押下でtextを表示する", async () => {
      await userEvent.click(canvas.getByTestId("button"));
      await expect(canvas.getByText("Success")).toBeInTheDocument();
    });

    await step("再度ボタン押下でtextを非表示にする", async () => {
      await userEvent.click(canvas.getByTestId("button"));
      await expect(canvas.queryByText("Success")).toBeNull();
    });
  },
};

export const Link: Story = {
  args: {
    label: "Link",
    href: "/auth/login",
    "data-testid": "button",
  },
  play: async ({ canvasElement, step }) => {
    const canvas = within(canvasElement);

    await step("ボタン押下でhrefで指定した画面に遷移する", async () => {
      await userEvent.click(canvas.getByTestId("button"));
      await expect(fn.mock.lastCall).toContainEqual("/auth/login");
    });
  },
};

```

Storybookのダッシュボードを立ち上げると
Atoms
	Button
		Default
		Primary
		Toggle
		Link

が表示されます。

Interactionsタブに移動すると
テストがPASSしています。





## カバレッジの計測

npm install -D @storybook/test-runner @storybook/addon-coverage

※カバレッジインストール後、storybookを再起動させておかないとエラーになります。

scriptsを追加します。

```package.json
{
 "scripts": {
 ...
 "test-storybook": "test-storybook --coverage",
 }
}

```



```.storybook/main.ts

const config: StorybookConfig = {
 addons: [
 ...
 '@storybook/addon-coverage',
 ],
};

```



カバレッジの計測にはstorybookを起動させておく必要があります。
npm run storybook

カバレッジの計測(新しいターミナルで実行します。)
npm run test-storybook


インタラクションテストの動作確認
カバレッジの計測を確認



----------------------------------------

# Supabase

このSupabase項目は

Supabase ローカル開発環境 ＋ サーバー運用を想定 2023 - Qiita

https://qiita.com/masakinihirota/items/be94b4c74a7850a4b79c

を参考にしてください。



ローカルにSupabaseのCLI (command line interface)をインストールします。

scoop bucket add supabase https://github.com/supabase/scoop-bucket.git
scoop install supabase

アップデート
scoop update supabase

Supabase CLIのバージョン
supabase --version



Supabase本体とクライアントとSupabase Authヘルパーのインストール
npm install supabase @supabase/supabase-js @supabase/auth-helpers-nextjs



Supabaseの初期化
supabase init



## サーバー側との接続（必要な場合）
Supabaseへのログイン
supabase login

Supabaseプロジェクトへのリンク
supabase link

## Dockerのインストール

Supabase ローカル開発環境 ＋ サーバー運用を想定 2023 - Qiita

https://qiita.com/masakinihirota/items/be94b4c74a7850a4b79c

を参考にしてください。


## ローカルのSupabaseを始める

supabase start

```
06-18 15:49:49> supabase start
Seeding data supabase\seed.sql...me...
                                 Started supabase local development setup.

         API URL: http://localhost:54321
     GraphQL URL: http://localhost:54321/graphql/v1
          DB URL: postgresql://postgres:postgres@localhost:54322/postgres
      Studio URL: http://localhost:54323
    Inbucket URL: http://localhost:54324
      JWT secret: super-secret-jwt-token-with-at-least-32-characters-long
        anon key: eyJhb**********************************n_I0
service_role key: eyJhbGci*******************************pN81IU

```

ステータス
supabase status

ローカルのSupabase(Docker)を止める
supabase stop

## Supabaseを利用したローカルでの開発

Supabase ローカル開発環境 ＋ サーバー運用を想定 2023 - Qiita

https://qiita.com/masakinihirota/items/be94b4c74a7850a4b79c

を参考にしてください。

## Supabaseクライアントの基礎

src\utils\supabase.tsという新しいファイルを作成し、以下の内容を追加します。

```src\utils\supabase.ts

import { createClient } from '@supabase/supabase-js'

export default createClient(
 process.env.NEXT_PUBLIC_SUPABASE_URL!,
 process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
)

```

これを呼び出すことでSupabaseクライアントが作成できます。





----------------------------------------

# サービスとの連携コマンド

プロジェクトをGitHubで公開して、それをVercelから連携させます。

取得した独自ドメインがあるのならドメイン登録もできます。

vercel関連
Next.js×Supabase×Vercel連携について - Qiita

https://qiita.com/kaho_eng/items/8a7faf77222a599fb31c

pnpm vercel login

Vercelプロジェクトをローカル環境にクローンしたプロジェクトにリンクします。
pnpm vercel link

環境変数を連携したVercelプロジェクトからコピーして .env.localに上書きできます。
pnpm vercel env pull

----------------------------------------

# Dark Mode

[WIP]

ダークモードの設定

Radix × Tailwindなshadcn/uiがいい感じ - Qiita

https://qiita.com/hajimism/items/e7bbe3711b43a8579224

Theming - shadcn/ui

https://ui.shadcn.com/docs/theming

Dark Mode - shadcn/ui

https://ui.shadcn.com/docs/dark-mode













































































----------------------------------------

# i18n

[WIP]





----------------------------------------

# 削除してもいいフォルダ

src\stories

このフォルダはStorybookをインストールするときにデフォルトで入ってくるサンプルなのでサンプルを見ながら書く人以外は消してしまってもいいです。

※コロケーションパターンで開発するので、コンポーネントファイル、テストファイル、Storyファイルはすべて同一のフォルダに入れます。
理由は半年前も経てばどのファイルがどのフォルダに入っているかわからなくなるからです。なのでコロケーションパターンの原則を出来る限り守ります。
グローバル化したいものや共通化したいものは除く。


----------------------------------------

# 参考URL

GitHub Qiita記事
Supabase ローカル開発環境 ＋ サーバー運用を想定 2023

https://qiita.com/masakinihirota/items/be94b4c74a7850a4b79c

GitHub masakinihirota/vns

https://github.com/masakinihirota/vns

Supabase VNS

https://app.supabase.com/project/gzctqdrrnnkaxwwtzbsw

Vercel VNS

https://vercel.com/masakinihirota/vns

Next.js by Vercel - The React Framework

https://nextjs.org/

Storybook

https://storybook.js.org/docs/react/get-started/install/

React×TypeScriptではじめるVitest

https://zenn.dev/bs_kansai/articles/b79d97a8f921d6

Storybook(v7)をVitestで再利用するとき

https://zenn.dev/pluto0004/articles/3bab7d07805cff

Storybookの「インタラクションテスト」でフロントエンドのテストをシンプルに管理する！｜SHIFT Group 技術ブログ

https://note.com/shift_tech/n/n5646b52b3092




[2023年]Next.js + eslint周りの設定

https://zenn.dev/resistance_gowy/articles/91b4f62b9f48ec

【環境構築】Next × App Router × Prettier × ESLint × Husky × Shadcn/ui の環境構築をしてみる - Qiita

https://qiita.com/hiroto_dnpk/items/a7ebbca3294c7befb4b7







----------------------------------------

# 未インストール

<details><summary>未インストール[WIP]</summary>

# vitest

テストツール

???
npm create vite@latest

React と TypeScript を選択します。

cd vitest-react
npm install
npm run dev

ここからインストール？
npm install -D vitest

npm install -D jsdom @testing-library/react @testing-library/jest-dom


.eslintignore
ファイル内にvitest.config.tsを書く

```
vite.config.ts
vitest.config.ts
.eslintrc.cjs

```

Vitest の設定
vite.config.ts



```vitest.config.ts
import { defineConfig } from 'vite'

export default defineConfig({
    test: {
        include: ['src/**/*.test.tsx'],
        environment: 'jsdom',
    },
})

```

src/以下のみに設定してある




## テストコードの作成

App コンポーネントに対して、「Vite + React」が表示されているかのテストを書いてみます。



```
import '@testing-library/jest-dom';
import { render, screen } from '@testing-library/react';
import { expect, test } from 'vitest';
import App from '../App';

test('renders h1 text', () => {
    render(<App />);
    const headerElement = screen.getByText("Vite + React");
    expect(headerElement).toBeInTheDocument();
});

```


実行
pnpm vitest

カバレッジの実行
pnpm vitest run --coverage




```
import { defineConfig } from 'vite'

export default defineConfig({
    test: {
        globals: true,
        include: ['src/**/*.test.tsx'],
        environment: 'jsdom',
        coverage: {
            reporter: ['html'],
            reportsDirectory: './coverage'
        },
    },
})

```



</details>
