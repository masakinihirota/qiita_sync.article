<!--
title:   Next.jsでの初心者向け Middleware.ts入門 (v13.1.0) ＋ 公式マニュアル 解説 ＋ 複数のMiddlewareの実装方法
tags:    Next.js,middleware
id:      30a5e06e3288031b9788
private: false
-->
追記 2024年2月15日

Routing: Middleware | Next.js
https://nextjs.org/docs/pages/building-your-application/routing/middleware

久しぶりに見返してみたら missingというキーワードが追加されていた。
ドキュメントのバージョンは13.1.0で変わってないので、ドキュメントの整備で追記されていたらしい。

>>You can also ignore prefetches (from next/link) that don't need to go through the Middleware using the missing array:

>>また、（next/linkからの）ミドルウェアを経由する必要のないプリフェッチも、missing arrayを使って無視することができる：

```middleware.js
export const config = {
  matcher: [
    /*
     * Match all request paths except for the ones starting with:
     * - api (API routes)
     * - _next/static (static files)
     * - _next/image (image optimization files)
     * - favicon.ico (favicon file)
     */
    {
      source: '/((?!api|_next/static|_next/image|favicon.ico).*)',
      missing: [
        { type: 'header', key: 'next-router-prefetch' },
        { type: 'header', key: 'purpose', value: 'prefetch' },
      ],
    },
  ],
}

```

追記終了


# 対象
Middlewareって何？
どんな事ができるの？
どんな機能があるの？
と疑問を持っている人。

切り貼りコピペで使っていた人（＝自分）向け。

Middleware について 初心者向けなことや Next.js 公式ドキュメントを調査していきます。



# Middlewareを5歳でも理解できるように説明をしてください。 (by GitHub Copilot chat)

ミドルウェア（Middleware）は、ちょうど「中間の仕事をする人」のようなものです。

例えば、あなたがレストランで食事をするとき、ウェイターがミドルウェアのような役割を果たします。あなた（クライアント）が注文をすると、ウェイター（ミドルウェア）はその注文を受け取り、厨房（サーバー）に伝えます。そして、厨房が料理（データ）を作ったら、ウェイターがそれをあなたに運びます。

このように、ミドルウェアはクライアントとサーバーの間で働き、リクエストとレスポンスを適切に処理します。ミドルウェアは、リクエストがサーバーに到達する前に何か特別な処理をしたり（例えば、セキュリティチェックを行ったり）、レスポンスをクライアントに送る前に何かをしたり（例えば、データを整形したり）します。



# Middlewareを複数に分ける意味

Middlewareにはたくさんの仕事があります、セキュリティであったり、認証であったり、リダイレクトであったり、リライトであったり、ログであったり、i18nであったり、キャッシュであったり、等など。

ブラウザからのリクエストを受け取り、Middlewareで処理を行い、Next.jsに渡しています。

Middlewareに行わせる処理によって仕事が変わるので、複数に分けて書くほうが書きやすいですし、読む方も理解しやすく、編集もしやすくなります。

1つのMiddlewareに全ての処理を書かないようにしましょう。



# Next.js Middleware ドキュメントについて

↓読むドキュメント

Routing: Middleware | Next.js

https://nextjs.org/docs/app/building-your-application/routing/middleware

※Middleware  v13.1.0 時点のドキュメントになります。



# Middlewareの主な仕事

ブラウザから送られてきたユーザーからのリクエストをNext.jsに **到達する前** にキャッチします。（※重要）

↑キャッチした後は・・・

URL リダイレクトを行います。
URL リライトを行います。
リクエストとレスポンスを変更します。
ヘッダーの強化します。
送受信リクエストの追跡をします。
Authentication 認証、アクセスの許可(Webアプリに入れるかどうかの判断をします。)
Authorization 認可、アクセスの制御(各データの取得を許可します。)
キャッシュ戦略 (頻繁にアクセスされるデータをキャッシュに保存します。)
Webアプリの閉鎖やメンテナンス (すべてのアクセスを禁止して、特定のページを表示します。)



# Middleware の欠点

Webアプリが複雑になる場合があります。
これにより、アプリケーションの開発、デプロイ、保守がより困難になる可能性があります。ミドルウェアによりアプリケーションのコストが増加する可能性があります。

アプリケーションに遅延を引き起こします。これは、アプリケーションがリクエストを処理する前にミドルウェア コードを実行する必要があるためです。



# Middlewareの拡張子

middleware.js
middleware.ts
この拡張子が使えます。



# Middleware の NextRequest と NextResponse

ブラウザからのリクエスト NextRequest を受け取り

NextResponse を次の相手に渡します。

渡す相手は、
Next.jsへそのまま渡したり
ブラウザを拒否したりします。

通常は、NextResponseのbodyに色々なデータを加工したりして渡します。



# Middlewareとは？の疑問

まず最初にユーザーからのリクエストを Middleware でキャッチして、様々な処理を行います。

Middleware には matcher というものがあり、ユーザーからのリクエストのパスが、

* matcherにマッチした場合
Middleware が実行されます。

* matcherにマッチしなかった場合
ユーザーのリクエストは Middleware を素通りして Next.js に渡されます。

なので、middlewareで処理したいパスをmatcherに書きます。

複数の処理（認証 log i18n）をしたい場合もこのmatcherに書いて、
middlewareで処理したいときに if 文などでパスの条件分岐を行います。



## Middleware が実行された場合の流れ。

次にユーザーに返すレスポンスを作成します。

そもそもMiddleware が最初から無い場合には 通常 Next.js が **レスポンスを作成** しますが、マッチャーにより引っかかったリクエストをMiddleware で行うので、 レスポンスを作成する作業を Middleware が行います。

たとえば、不正な リクエスト を弾いた場合に Middleware が Next.js の代わりにレスポンスを返すのでこの作業は必ず必要です。

なので、Middleware は Next.jsとは別に独立したバックエンドの一種と考えれば理解しやすいと思います。

ユーザーからのリクエストの毒見役というか、検閲役というか、そんな役割が Middleware に求められます。

受け付けたユーザーからのリクエストを検閲して、

不正なリクエストなら受け付けられないというレスポンスをユーザーに返します。

正常なリクエストならば、Next.jsに渡します。



## Middleware が作成するレスポンス

Middleware はレスポンスを作りますが、その中身は当然 空っぽです。
通常、中身を作る作業はNext.jsで行うのですから、Middleware にそんな能力はありませんので、返す形だけを作ります。

実際のコードはこのようになります。

```middleware.ts

const res = NextResponse.next()

```

このように レスポンスを作ります。 しかしこの中身はレスポンスの形だけが決まっているだけの空っぽな const変数 です。

※const 変数は 再代入出来ないという規則がありますが、配列やオブジェクトの場合、中身を変更することが可能です。



つまり この const の宣言は 箱の形だけは決まって変えられないけど、中身は空っぽな箱で色々詰められる ということになります。

↑この箱は ユーザーにもNext.jsにも渡すことが出来ます。中身は単なる空っぽの箱ですが共通の規格なのでブラウザもNext.jsも利用することが可能だからです。



## Middlewareの能力を実行する。
そして空っぽのレスポンスを作った後に、ユーザーからのリクエストの解析に入ります。

ユーザーからのリクエストはどんなものかを調べて、それに応じてそのままユーザーに返すか、Next.jsに引き渡すかを判断する処理を書きます。

これが middleware 基本的な考え方です。

サーバーが起動中は、**ユーザーからのリクエストを受け取り、レスポンスを返す。**
これを繰り返します。

なので、

```
return NextResponse.next()

```

このようにそのままを返すということは、Middlewareで何も処理せずに、受け取ったものをそのままNext.jsにわたすという意味になります。



# サンプルを見てみる

ここでサンプルを見てみます。

Next.js には Middleware の↓公式サンプルがあります。

middleware

https://github.com/vercel/next.js/tree/canary/examples/middleware

↑このリポジトリの ↓ middleware.ts を見てみます。

```middleware.ts
import { NextRequest, NextResponse } from 'next/server'

export function middleware(request: NextRequest) {
  if (request.nextUrl.pathname === '/about') {
    return NextResponse.redirect(new URL('/redirected', request.url))
  }
  if (request.nextUrl.pathname === '/another') {
    return NextResponse.rewrite(new URL('/rewrite', request.url))
  }
  return NextResponse.next()    ＜＜＜ 到達不可能
}

export const config = {
  matcher: ['/about/:path*', '/another/:path*'],
}

```

文法は2つのシンプルなif文と、何もなかったら 空のレスポンスを 返す return文 というごく単純なコードです。

config に関しては後述



NextRequest と NextResponse は単なる型です。

3行目のコード
request.nextUrl.pathname === '/about'

trueならばリダイレクトを行います。

7行目のコード
request.nextUrl.pathname === '/another'

trueならばリライトを行います。



## redirectと rewrite という2つの処理の違い

redirect
クライアントを別のURLに転送することを目的としています。

rewrite
クライアントがアクセスしたURLを別のURLに書き換えることを目的としています。



## const config

この const config は Middleware が自動的に読み込みます。

このコードでは matcher が設定してあり、ユーザーからのリクエストのパスがこの matcher にマッチした場合に、このMiddlewareが実行されます。

matcherが設定されているため、マッチしないユーザーのリクエストはこのミドルウェアを通過しません。その結果、最後のReturn文は実質的に到達することはありません。


## Middleware の配置場所について

Next.jsでのMiddleware は
root/
app/
pages/
と同じ階層に配置できます。

※重要: Next.jsのインストール時に srcフォルダを作った場合は、srcフォルダの下にmiddleware.tsファイルを置いてください。

```
src/middleware.ts

```



## Middleware の実行パス

マッチャーにより引っかかったリクエストに対して実行します。
リクエストを解析したパスを 条件分岐で分けます。

マッチャーには正規表現を使用できます。

マッチャー
サンプルコードより

/about/:path*
/another/:path*

/about/や/another/
ユーザーのリクエストがこのパスにマッチした場合に、この Middleware が実行されます。

:path*
コロンは名前付きパラメータを表します。

プレースホルダー
:[文字列]

プレースホルダーとは、あらかじめ決まっていない値を表すために、一時的に置かれる場所のことを指します。プログラミングにおいては、プレースホルダーは、変数や引数、フォーマット文字列などの形で使用されます。
Webアプリケーションにおいては、URLのパスにプレースホルダーを使用することで、動的なページを生成することができます。
プログラミングにおいては、プレースホルダーは、可読性や保守性を高めるためにも重要な役割を果たします。



`matcher`の`:path*`はプレースホルダーの1つです。
`/about/:path*`というパスは、`/about`の後に`/`で区切られた任意の文字列を含むパスにマッチします。
例えば、`/about/foo`や`/about/bar/baz`にマッチします。

このように、 プレースホルダー を使用することで、動的なパスを扱うことができます。`matcher`には、他にもプレースホルダーがあります。例えば、`:id`は数値のIDを表し、`:slug`は文字列のスラッグを表します。

`*` は正規表現で、0回以上の繰り返しを表します。


複数のURLパターンをマッチさせることができます。

matcher: ['/about/:path*', '/dashboard/:path*'],

このように配列に入れることで、複数のパスのパターンを設定できます。

ここまでの説明で、
マッチャーで複数のパスを設定することができること、
そして、その複数のそれぞれ個別のパスに対して、それぞれ個別の処理を行いたい場合は、ifなどの条件式を使って、それぞれのパスに対して処理を行うことになります。



## /about/:path* にマッチする例

/about/   ＜＜0回以上の繰り返しなので、このパスにもマッチします。
/about/foo
/about/bar/baz



## startsWith()というメソッド

request.nextUrl.pathname

↑この pathname には startsWith() というメソッドがあります。

使用例
request.nextUrl.pathname.startsWith('/about')

/aboutにマッチするパスがあった場合に、この コード が実行されます。



# NextResponse

NextResponseのコードを遡ってみていくと、(VSCode の F12ボタン)

```response.d.ts
declare const INTERNALS: unique symbol;
export declare class NextResponse<Body = unknown> extends Response {
    [INTERNALS]: {
        cookies: ResponseCookies;
        url?: NextURL;
        body?: Body;
    };
    constructor(body?: BodyInit | null, init?: ResponseInit);
    get cookies(): ResponseCookies;
    static json<JsonBody>(body: JsonBody, init?: ResponseInit): NextResponse<JsonBody>;
    static redirect(url: string | NextURL | URL, init?: number | ResponseInit): NextResponse<unknown>;
    static rewrite(destination: string | NextURL | URL, init?: MiddlewareResponseInit): NextResponse<unknown>;
    static next(init?: MiddlewareResponseInit): NextResponse<unknown>;
}

```

こんな感じです、ジェネリック型というものが使われています。
そのジェネリック型はBodyでありデフォルト値はunknownです。


つまり NextResponseは基本の値は全て決まっていてあとから
開発者がBodyにデータを入れる形になっているということになります。

開発者はこのBodyにMiddleware で加工したデータを入れていきます。



[INTERNALS]は配列ではなくて、2015年に追加されたシンボルです。

※シンボルとは、プリミティブ型の一種で、文字列と似ていますが、文字列とは異なり、同じ値を持つシンボルは必ず異なるものとして扱われます。
unique symbolと宣言されているので、このシンボルは一意であることが保証されています。



## NextResponseの解説

```typescript
declare const INTERNALS: unique symbol;
```

`const`キーワードを使用して、`INTERNALS`という名前の定数を宣言しています。`unique symbol`は、一意のシンボルを表す型です。

```typescript
export declare class NextResponse<Body = unknown> extends Response {
```

`NextResponse`というクラスを宣言しています。`<Body = unknown>`は、ジェネリック型の宣言で、`Body`という型引数を持ち、デフォルト値として`unknown`を指定しています。`extends Response`は、`NextResponse`が`Response`クラスを継承することを示しています。

```typescript
[INTERNALS]: {
    cookies: ResponseCookies;
    url?: NextURL;
    body?: Body;
};
```

`[INTERNALS]`というプロパティに、`cookies`、`url`、`body`というプロパティを持つオブジェクトを定義しています。`cookies`は、`ResponseCookies`型、`url`は、`NextURL`型、`body`は、`Body`型です。

```typescript
constructor(body?: BodyInit | null, init?: ResponseInit);
```

`constructor`メソッドを定義しています。`body`と`init`という2つの引数を持ちます。`body`は、`BodyInit`型または`null`、`init`は、`ResponseInit`型です。

```typescript
get cookies(): ResponseCookies;
```

`cookies`というgetterメソッドを定義しています。戻り値の型は、`ResponseCookies`です。

```typescript
static json<JsonBody>(body: JsonBody, init?: ResponseInit): NextResponse<JsonBody>;
```

`json`という静的メソッドを定義しています。`<JsonBody>`は、ジェネリック型の宣言で、`JsonBody`という型引数を持ちます。`body`と`init`という2つの引数を持ちます。戻り値の型は、`NextResponse<JsonBody>`です。

```typescript
static redirect(url: string | NextURL | URL, init?: number | ResponseInit): NextResponse<unknown>;
```

`redirect`という静的メソッドを定義しています。`url`と`init`という2つの引数を持ちます。`url`は、`string`型、`NextURL`型、`URL`型のいずれかを受け取ることができます。`init`は、`number`型または`ResponseInit`型です。戻り値の型は、`NextResponse<unknown>`です。

```typescript
static rewrite(destination: string | NextURL | URL, init?: MiddlewareResponseInit): NextResponse<unknown>;
```

`rewrite`という静的メソッドを定義しています。`destination`と`init`という2つの引数を持ちます。`destination`は、`string`型、`NextURL`型、`URL`型のいずれかを受け取ることができます。`init`は、`MiddlewareResponseInit`型です。戻り値の型は、`NextResponse<unknown>`です。

```typescript
static next(init?: MiddlewareResponseInit): NextResponse<unknown>;
```

`next`という静的メソッドを定義しています。`init`という1つの引数を持ちます。`init`は、`MiddlewareResponseInit`型です。戻り値の型は、`NextResponse<unknown>`です。

以上が、`NextResponse`クラスの定義に関する解説です。

このクラスは、Next.jsのMiddlewareで使用されるレスポンスオブジェクトを拡張したものであり、`redirect`や`rewrite`などのメソッドを提供しています。

以上がNextResponseの簡易な説明です。



# 2つ目の Middleware

Middleware で1つのチェックをする方法は学びました、次は複数のチェックをする場合、Middleware で実現するのはどうすればいいかと言う問題が出てきましたので調べたいと思います。

Middlewareで先程2つのPathをチェックしました。そしてそれぞれマッチした場合に、リダイレクトとリライトを行いました。
しかし、Middlewareで他の処理を行いたい場合もあります。その場合はどうすればいいのでしょうか？

↓Middlewareで行いたい処理。

Path  ＜＜Pathをチェックした例を前項目で解説しました。
認証   ＜＜他にもMiddlewareで行いたい処理があります。
log
i18n



## 定義

Middlewareの1つの仕事

`matcher`で指定された1つのパスにマッチするリクエストに対して、ミドルウェア関数を実行する。

例えば、国際化 i18n でマッチする matcher の設定と、認証にマッチする matcher の設定をそれぞれ1つと数えます。



<details><summary>Middleware を調べた時に躓いたこと</summary>

Middlewareを調べていて
最初に躓くのが Middleware 自身の理解とその立ち位置

自分は、フロントエンド、バックエンド、DBに続く第4番目の役割、立ち位置と考えています。

認証は扉をつくって鍵をかけ、開くという役割。
DBはRLS(Row Level Security)等のポリシーで鍵をかけますが、

Middleware は 門番という役割でしょうか。
全通信のチェックをします。

次が見知らぬ文法でした。
オブジェクトに配列記号の[]を使ってシンボルを作るとうことを初めて勉強しました。

そして第三の壁が 2つ目のMiddleware を追加する時どうすればいいのかという問題でした。

</details>

これから、2つ目の Middleware を 実装する方法を調べていきます。



# 複数の処理を middleware.ts 1ファイルで行う？

まずは0個の処理、つまり受け流すだけの処理を書きます。
そこを基礎として1つづ増やしていく方法を考えます。



でもその前にすこし問題です。

<details><summary>問題1</summary>

## 問題1
Next.js 13 App router の middlewareに `console.log` を書いた場合、どこに出力されるでしょうか？



## シンキングタイム

まず、middlewareの役割を思い出してみましょう。middlewareは、ブラウザからのリクエストをサーバーで処理する前に、様々な処理を行うためのものです。つまり、サーバーに到達する前にmiddlewareが処理を実行する必要があります。

次に、`console.log`がどこに出力されるかを考えてみましょう。`console.log`は、ブラウザのコンソール画面に出力されます。しかし、middlewareはサーバーサイドで実行されるため、ブラウザのコンソール画面には出力されません。

つまり、middlewareに`console.log`を書いた場合、サーバーサイドのコンソール画面に出力されます。



middlewareの立ち位置をもう一度考えてください。

middlewareは基本的にブラウザからのリクエストをサーバーで処理する前に、様々な処理を行う検問所みたいな役割を持ちます。

つまり、サーバー到達前にmiddlewareが処理を実行する必要があります。

サーバーに到達する前に処理を実行するのならば console.logはブラウザ側のコンソール画面に出るでしょうか？

どこに出力されるのか、少し考えてみてください。

</details>



<details><summary>回答1</summary>

## 回答1

答えはサーバー側です。
Next.js のmiddlewareは単なる Next.js 機能の一つでしかありません。



Next.js 13 App router の全てはサーバーサイドで処理をするようになりました。

では、middlewareに'use client'を付けたらどこで実行されるでしょうか？

これも答えはサーバー側です。

'use client' ディレクティブを付けても付けなくても
middlewareはサーバー側に console.logを出力します。
'use server' ディレクティブを付けても同じです。

App routerやディレクティブなどに関係なくNext.jsではmiddlewareをサーバーサイドの処理として扱っています。

なのでどのように設定しても答えはサーバー側になります。

ただユーザーのリクエストの流れは Next.jsとmiddlewareはそれぞれ独立しています。



</details>



<details><summary>問題2</summary>

## 問題2

↓このように matcher を消したらmiddlewareはどうなるでしょうか？

```
export const config = {};

```

* A すべてのパスをmiddlewareがチェックをします。
* B すべてのパスはmiddlewareを素通りします。
* C Next.jsのアプリケーションの設定に依るので不定である。

## シンキングタイム

何も設定していないのならmiddlewareの機能は働かないのか？
もし、すべてmiddlewareを通るのなら単に負荷がかかるだけではないのか？



</details>

<details><summary>回答2</summary>

答えはすべてのパスを middleware がチェックをします。
matcherというフィルターを掛けて、マッチしたパスだけをmiddlewareがチェックをします。
そのフィルターが無いのですべてのユーザーからのリクエストをmiddlewareがチェックをします。
middleware.ts を設定した以上当然の処理の流れです。

</details>

<details><summary>問題3</summary>

~~面倒になったので~~ ここからは駆け足で 解答も書いていきます。

Q ↓このように matcherを消して、リロードしたらどうなる？

```
export const config = {};

```

* A キャッシュが効いているのでmiddlewareは働かない。
* B すべてのパスをmiddlewareがチェックをします。 ＜＜＜正解



Q matcherは設定してあるが、配列が空の場合は？

```middleware.ts
export const config = {
  matcher: [],
};

```

* A matcherを設定していない時と同じになる。

* B ↓root "/" が設定してある場合と同じになる。

```
export const config = {
  matcher: ["/"],
};

```

それにキャッシュは効かないのでconsole.logはリロード毎に表示される。

* C root "/" が設定してある場合と同じになる。 ＜＜＜正解
しかし、キャッシュが効いている？ので middlewareは動かない。
(console.logで表示されない。)
※ブラウザをリロードしても console.log は表示されます。



Q matcher の設定を空にする

```
export const config = {
  matcher: [""],
};

```

* A matcherを設定していない時と同じになる。

* B root "/" が設定してある場合と同じになる。

* C root "/" が設定してある場合と同じになる。
それにキャッシュが効いているので middlewareは動かない。
(console.logで表示されない。)

* D Error: Invalid middleware found と報告が表示され、エラーになり（開発）サーバーが落ちる。 ＜＜＜正解

Next.js issue#57388

https://github.com/vercel/next.js/issues/57388



</details>

# Middlewareの図解

* 上が普通のブラウザからWebアプリへのデータの流れ
* 下が、ユーザーのリクエストの流れです。
図のようにMiddlewareが門番のようにユーザーのリクエストをチェックしています。

![Middleware-04.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/44761/036da29a-731d-89cc-fbf2-3547ec43a3f5.png)


実際に動かしてみます。

```middleware.ts
import { NextRequest, NextResponse } from "next/server";

export function middleware(request: NextRequest) {
  console.log(
    "middleware.ts: request.nextUrl.pathname",
    request.nextUrl.pathname
  );

  return NextResponse.next();
}

export const config = {};

```

↑このコードはmiddlewareに何の処理もさせていません、console.logを表示させているだけです。

ローカルサーバー(npm run dev)を立ち上げるだけで、

```terminal
middleware.ts: request.nextUrl.pathname /
middleware.ts: request.nextUrl.pathname /_next/static/webpack/934f8f934d3a6f9d.webpack.hot-update.json
middleware.ts: request.nextUrl.pathname /
middleware.ts: request.nextUrl.pathname /_next/static/chunks/webpack.js
middleware.ts: request.nextUrl.pathname /_next/static/chunks/react-refresh.js
middleware.ts: request.nextUrl.pathname /_next/static/chunks/main.js
middleware.ts: request.nextUrl.pathname /_next/static/chunks/pages/_app.js
middleware.ts: request.nextUrl.pathname /_next/static/development/_buildManifest.js
middleware.ts: request.nextUrl.pathname /_next/static/development/_ssgManifest.js
middleware.ts: request.nextUrl.pathname /_next/static/chunks/pages/index.js
middleware.ts: request.nextUrl.pathname /_next/static/development/_devMiddlewareManifest.json
middleware.ts: request.nextUrl.pathname /_next/static/development/_devPagesManifest.json
middleware.ts: request.nextUrl.pathname /favicon.ico

```

このようにmiddlewareを通ってきたことがterminalに出力されています。

ではconfigに "/" ルートだけを設定してみます。

```middleware.ts
export const config = {
  matcher: ["/"],
};

```

ブラウザをリロードすると

```terminal
middleware.ts: request.nextUrl.pathname /

```

middleware はルートだけをチェックしたことがわかります。

middleware はconst config を自動的に読み込まれていることがわかります。
そして主に config には マッチャーが設定されます。



# 1つ目の処理の追加

Next.js 公式サンプル middleware

next.js/examples/middleware at canary · vercel/next.js

https://github.com/vercel/next.js/tree/canary/examples/middleware

middlewareは↓このようになっています。

```middleware.ts
import { NextRequest, NextResponse } from 'next/server'

export function middleware(request: NextRequest) {
  if (request.nextUrl.pathname === '/about') {
    return NextResponse.redirect(new URL('/redirected', request.url))
  }
  if (request.nextUrl.pathname === '/another') {
    return NextResponse.rewrite(new URL('/rewrite', request.url))
  }
  return NextResponse.next()
}

export const config = {
  matcher: ['/about/:path*', '/another/:path*'],
}

```

このサンプルを動かすと
トップページに3つのリンクが表示されます。

## Go to about page (will redirect)

1つの目リンクを押します。
リンクは
http://localhost:3000/about
でしたが、

表示されたページは

http://localhost:3000/redirected

とリダイレクトされました。

ファイルはこのファイルが表示されています。
pages/redirected.tsx



## Go to another page (will rewrite)

2つ目のリンクを押します。

http://localhost:3000/another

↑リンクはanotherで移動した先もanotherでした、

http://localhost:3000/another

しかし表示されたページは

pages/rewrite.tsx
のページが表示されました。


### 解説

このコードは、TypeScriptで書かれたmiddlewareファイルの一部で、`request`オブジェクトの`nextUrl`プロパティの`pathname`プロパティが`"/another"`と等しいかどうかをチェックします。

もし等しい場合、`request`オブジェクトと同じベースURLを持つパスが`/rewrite`の新しいURLオブジェクトを作成し、それを`NextResponse.rewrite()`メソッドに渡します。

このメソッドは、URLを新しいURLに書き換えるようにNext.jsに指示する`NextResponse`オブジェクトを返します。





# Middlewareを使って基本的な関数の基礎を学ぶ

Middlewareに仕事をさせる前に関数の基礎について学びます。



```middleware.ts
import { NextRequest, NextResponse } from "next/server";

export function middleware(request: NextRequest) {
  const url = request.url;
  console.log("middleware1 =>", { url });

  return NextResponse.next();
}

export const config = {
  matcher: ["/"],
};

```

↑http://localhost:3000/ をリロードすると
リクエストURLを Terminal に表示します。

現在Middlewareは request: NextRequest を受け取って NextResponse.next を投げているだけです。



次にpathnameをターミナルに表示してみます。

```middleware.ts
import { NextRequest, NextResponse } from "next/server";

export function middleware(request: NextRequest) {
  const url = request.url;
  console.log("middleware1 =>", { url });

  const pathname = request.nextUrl.pathname;
  console.log("middleware2 =>", { pathname });

  return NextResponse.next();
}

export const config = {
  matcher: ["/"],
};

```

{ pathname } はオブジェクトの短縮記法であり、
キーと値が同じオブジェクトを作ります。

{ pathname } は{ pathname: pathname } と同じ意味です。



これでmiddlewareが2つ出来ました。

これを2つのmiddleware関数に分割してみます。



```middleware.ts
import { NextRequest, NextResponse } from "next/server";

function middleware1(request: NextRequest) {
  const url = request.url;
  console.log("middleware1 =>", { url });

  return NextResponse.next();
}

function middleware2(request: NextRequest) {
  const pathname = request.nextUrl.pathname;
  console.log("middleware2 =>", { pathname });

  return NextResponse.next();
}

export function middleware(request: NextRequest) {
  middleware1(request);
  middleware2(request);
}

export const config = {
  matcher: ["/"],
};

```

ターミナルの出力を見ると結果は同じに表示されているはずです。

次にこれらを非同期に実行してみます。



```middleware.ts
import { NextRequest, NextResponse } from "next/server";

async function middleware1(request: NextRequest) {
  const url = request.url;
  console.log("middleware1 =>", { url });

  return NextResponse.next();
}

async function middleware2(request: NextRequest) {
  const pathname = request.nextUrl.pathname;
  console.log("middleware2 =>", { pathname });

  return NextResponse.next();
}

export async function middleware(request: NextRequest) {
  await middleware1(request);
  await middleware2(request);
}

export const config = {
  matcher: ["/"],
};

```

非同期にしてもターミナルの出力は同じ結果になると思います。

```terminal
middleware1 => { url: 'http://localhost:3000/' }
middleware2 => { pathname: '/' }

```

以上が一番シンプルな分割パターンです。



## 高階関数パターン

次に高階関数パターンを見てみます。
名前は手強そうですが、コードを追っていけば関数を重ねているだけだとわかります。

```middleware.ts
import {
  NextFetchEvent,
  NextMiddleware,
  NextRequest,
  NextResponse,
} from "next/server";

// async function middleware1(request: NextRequest) {
//   const url = request.url;
//   console.log("middleware1 =>", { url });

//   return NextResponse.next();
// }

function withMiddleware1(middleware: NextMiddleware) {
  return async (request: NextRequest, event: NextFetchEvent) => {
    const url = request.url;
    console.log("middleware1 =>", { url });

    return middleware(request, event);
  };
}

async function middleware2(request: NextRequest) {
  const pathname = request.nextUrl.pathname;
  console.log("middleware2 =>", { pathname });

  return NextResponse.next();
}

export default withMiddleware1(middleware2);

// export async function middleware(request: NextRequest) {
//   await middleware1(request);
//   await middleware2(request);
// }

export const config = {
  matcher: ["/"],
};

```

middleware1()を一旦消して、withMiddleware1()を高階関数として定義しました。

高階関数は関数を渡して関数を返してもらうので、コードを見るとreturn文が2つあるので奇妙に見えますが、**関数そのものを返している**ので単なる返り値です。

↓返り値はwithMiddleware1が受け取ったmiddleware2関数を実行して、middleware2の実行結果を返しています。

```
return middleware(request, event);

```






















これも出力を見ると、前回の出力と同じに表示されているはずです。

Next.jsやブラウザに返すのはNextResponse.next();
MiddlewareからMiddlewareに渡すのは middleware: NextMiddleware です。
このパターンを忘れないようにしましょう。



3番目のMiddlewareを作る場合は2番目のMiddlewareを1番と同じようにします。

``` (動きません)middleware.ts
import {
  NextFetchEvent,
  NextMiddleware,
  NextRequest,
  NextResponse,
} from "next/server";

// async function middleware1(request: NextRequest) {
//   const url = request.url;
//   console.log("middleware1 =>", { url });

//   return NextResponse.next();
// }

function withMiddleware1(middleware: NextMiddleware) {
  return async (request: NextRequest, event: NextFetchEvent) => {
    const url = request.url;
    console.log("middleware1 =>", { url });

    return middleware(request, event);
  };
}

async function middleware2(request: NextRequest) {
  const pathname = request.nextUrl.pathname;
  console.log("middleware2 =>", { pathname });

  return NextResponse.next();
}

function withMiddleware2(middleware: NextMiddleware) {
  return async (request: NextRequest, event: NextFetchEvent) => {
    const pathname = request.nextUrl.pathname;
    console.log("middleware2 =>", { pathname });

    return middleware(request, event);
  };
}

// export default withMiddleware1(middleware2);
export default withMiddleware1(withMiddleware2(middleware3));
// 高階関数でラップすることでmiddlewareをチェーンできます。
// しかしまだ、↑middleware3をまだ作ってないので動きません。

// export async function middleware(request: NextRequest) {
//   await middleware1(request);
//   await middleware2(request);
// }

export const config = {
  matcher: ["/"],
};

```








# 複数個のMiddlewareをchain関数でつなげる。

引数にMiddlewareを入れ子にしていくのは無理があるので
別フォルダを作ってそこから呼び出せるようにします。

https://github.com/HamedBahram/next-middleware-chain

https://github.com/jmarioste/next-middleware-guide



root直下もしくはsrcの下に middlewares フォルダを作成します。


複数のMiddlewareを受け取るベースを作ります。

```middlewares/chain.ts
import { NextMiddleware, NextResponse } from "next/server";

type MiddlewareFactory = (middleware: NextMiddleware) => NextMiddleware;

export function chain(
  functions: MiddlewareFactory[],
  index = 0
): NextMiddleware {
  const current = functions[index];

  if (current) {
    const next = chain(functions, index + 1);
    return current(next);
  }

  return () => NextResponse.next();
}
```

これでMiddlewareを繰り返し読み込み、そして返す関数が出来たので

次は
独立したMiddlewareの機能(withMiddleware1,withMiddleware2)をmiddlewaresフォルダの下に移動します。

```middlewares/middleware1.ts
import { NextMiddleware, NextRequest, NextFetchEvent } from "next/server";

export function withMiddleware1(middleware: NextMiddleware) {
  return async (request: NextRequest, event: NextFetchEvent) => {
    const url = request.url;
    console.log("middleware1 =>", { url });

    return middleware(request, event);
  };
}

```

```middlewares/middleware2.ts
import { NextMiddleware, NextRequest, NextFetchEvent } from "next/server";

export function withMiddleware2(middleware: NextMiddleware) {
  return async (request: NextRequest, event: NextFetchEvent) => {
    const pathname = request.nextUrl.pathname;
    console.log("middleware2 =>", { pathname });

    return middleware(request, event);
  };
}

```

次はこれらをmiddlewareで読み込めるようにします。

```middleware.ts
import { chain } from "./middlewares/chain";
import { withMiddleware1 } from "./middlewares/middleware1";
import { withMiddleware2 } from "./middlewares/middleware2";

export default chain([withMiddleware1, withMiddleware2]);

export const config = {
  matcher: ["/"],
};

```

これでhttp://localhost:3000/を開くと今までと同じ結果が表示されると思います。

```terminal
middleware1 => { url: 'http://localhost:3000/' }
middleware2 => { pathname: '/' }

```

この方法なら
export default chain([withMiddleware1, withMiddleware2]);
ここらへんの配列をいじればMiddlewareを1つづつ動作確認とか出来ますね。
まぁ本来ならテストを書けって話なんですが・・・

これで複数のMiddlewareを設定する方法は終了です。

新しいMiddlewareの機能を追加したければ、
middlewaresフォルダにmiddleware?.tsファイルを追加すればいいだけです。



# 便利なMiddleware機能

参考サイトからコードを引っ張ってきます。

## IP制限

```widthIpRestriction.ts
import {
  NextFetchEvent,
  NextMiddleware,
  NextRequest,
  NextResponse,
} from "next/server";

export function widthIpRestriction(middleware: NextMiddleware) {
  return async (request: NextRequest, event: NextFetchEvent) => {
    // ##################################################
    // IP制限
    //
    // 全てのパスに対してIP制限を実行します。
    // ##################################################
    // ホワイトリストに登録されたIPリストを取得します。
    const ipWhiteList = new Set(
      process.env.IP_WHITE_LIST?.split(",").map((item: string) => {
        return item.trim();
      })
    );
    // ホワイトリストに登録されていないIPアドレスからのアクセスは拒否します。
    if (request.ip && !ipWhiteList.has(request.ip as string)) {
      const log = {
        message: `許可されていないIPアドレスからのアクセスのためアクセスを拒否しました`,
        ip: request.ip,
        url: request.nextUrl.pathname,
        method: request.method,
      };
      console.log(log);
      return new NextResponse(null, { status: 401 });
    }

    return middleware(request, event);
  };
}

```

ホワイトリスト

```.env
IP_WHITE_LIST=xxx.xxx.xxx.xxx, yyy.yyy.yyy.yyy

```



### 解説

このコードは、IP 制限を実装するための関数です。IP 制限を行うことで、許可された IP アドレス以外からのアクセスを拒否することができます。

この関数では、環境変数 `IP_WHITE_LIST` に登録された IP アドレスのリストを取得し、リストに含まれていない IP アドレスからのアクセスを拒否します。また、アクセスが拒否された場合には、ログを出力して `401 Unauthorized` ステータスコードを返します。

この関数を使用することで、簡単に IP 制限を実装することができます。また、環境変数を使用して IP アドレスのリストを管理するため、柔軟に設定を変更することができます。

ただし、IP 制限を行うため、許可された IP アドレスからのアクセスでも、制限に引っかかる可能性があります。また、環境変数を使用しているため、設定が誤っている場合には、誤った IP アドレスからのアクセスを許可してしまう可能性があります。



## ログ出力

```withLogging.ts
import { NextFetchEvent, NextMiddleware, NextRequest } from "next/server";

export function widthLogging(middleware: NextMiddleware) {
  return async (request: NextRequest, event: NextFetchEvent) => {
    // ##################################################
    // ログ出力
    //
    // パスが以下の場合にログを出力します。
    // ・"/"から始まり、"."を含まない任意のパス
    // ・"/_nextから始まらない任意のパス
    // ・"/"のルートパス。
    // ・"/api"から始まる任意のパス
    // ・"/trpc"から始まる任意のパス
    // ##################################################
    if (
      request.nextUrl.pathname.match(/\/(?!.*\..*|_next).*/) ||
      request.nextUrl.pathname.match(/\/(api|trpc)(.*)/) ||
      request.nextUrl.pathname === "/"
    ) {
      // リクエストの情報をJSON形式で出力します。
      const log = {
        ip: request.ip,
        geo: request.geo,
        url: request.nextUrl.pathname,
        method: request.method,
      };
      console.log(JSON.stringify(log, (k, v) => (v === undefined ? null : v)));
    }

    return middleware(request, event);
  };
}

```

### 解説

このコードは、ログ出力を行うための関数です。この関数では、特定のパスにアクセスされた場合にログを出力します。

ログを出力する条件は以下の通りです。
- パスが "/" から始まり、"." を含まない任意のパス
- パスが "/_next" から始まらない任意のパス
- パスが "/" のルートパス
- パスが "/api" から始まる任意のパス
- パスが "/trpc" から始まる任意のパス

ログ出力の際には、リクエストの情報を JSON 形式で出力します。出力する情報は、IP アドレス、地理情報、URL、HTTP メソッドです。



## i18n

```middleware.js
import { NextResponse } from "next/server"
import acceptLanguage from "accept-language"

import { fallbackLng, languages, cookieName } from "./app/i18n/settings"

acceptLanguage.languages(languages)

export const config = {
  // matcher: '/:lng*'
  matcher: ["/((?!api|_next/static|_next/image|assets|favicon.ico|sw.js).*)"],
}

export function middleware(req) {
  let lng
  if (req.cookies.has(cookieName)) lng = acceptLanguage.get(req.cookies.get(cookieName).value)
  if (!lng) lng = acceptLanguage.get(req.headers.get("Accept-Language"))
  if (!lng) lng = fallbackLng

  // Redirect if lng in path is not supported
  if (
    !languages.some((loc) => req.nextUrl.pathname.startsWith(`/${loc}`)) &&
    !req.nextUrl.pathname.startsWith("/_next")
  ) {
    return NextResponse.redirect(new URL(`/${lng}${req.nextUrl.pathname}`, req.url))
  }

  if (req.headers.has("referer")) {
    const refererUrl = new URL(req.headers.get("referer"))
    const lngInReferer = languages.find((l) => refererUrl.pathname.startsWith(`/${l}`))
    const response = NextResponse.next()
    if (lngInReferer) response.cookies.set(cookieName, lngInReferer)
    return response
  }

  return NextResponse.next()
}

```


### 解説

このコードは、i18n（国際化）のためのミドルウェアです。このミドルウェアでは、クッキーや Accept-Language ヘッダーから言語を取得し、言語に応じたリダイレクトを行います。

まず、`accept-language` パッケージを使用して、言語の設定を行います。次に、`config` オブジェクトを定義して、matcher を設定します。matcher は、どの URL にこのミドルウェアを適用するかを指定するものです。

次に、`middleware` 関数を定義しています。この関数では、クッキーや Accept-Language ヘッダーから言語を取得し、言語に応じたリダイレクトを行います。

まず、クッキーから言語を取得します。クッキーが存在しない場合は、Accept-Language ヘッダーから言語を取得します。どちらも取得できない場合は、fallbackLng というデフォルトの言語を設定します。

次に、リクエストされた URL がサポートされている言語でない場合は、言語に応じた URL にリダイレクトします。

最後に、referer ヘッダーから言語を取得し、クッキーに設定します。











































----------------------------------------
----------------------------------------
----------------------------------------


ここより下は、Nexe.js公式ドキュメントの内容と解説です。

# Middlewareとは？

Middleware は、
ユーザーからのリクエストに対して、レスポンスを返す前に、Middlewareで様々な処理を行うことができます。

例えば

* リダイレクト
* リクエスト
* レスポンスを書き換えが出来ます。
* レスポンスのヘッダーを変更出来ます。
* 直接レスポンスを返す事が出来ます。
* 認証済みかどうかを確認して、リクエストを処理するかどうかを決定することができます。
* リクエストに基づいて、レスポンスに対する処理を行うことができます。

このように、middlewareを使用することで、Webアプリケーションの動作をより細かく制御することができます。



# Middlewareを定義する場所

Middleware（Middleware）を定義するには、プロジェクトのルートにある `middleware.ts`（または `.js`）というファイルを使います。例えば、`pages` や `app` と同じレベルに置くか、該当する場合は `src` フォルダの中に置きます。

Middlewareは、Webアプリケーションの動作をより細かく制御することができます。例えば、リクエストやレスポンスを変更したり、リダイレクトしたりすることができます。

以下は、`middleware.ts` ファイルの例です。

```typescript
import { NextResponse } from 'next/server'
import type { NextRequest } from 'next/server'

export function myMiddleware(req: NextRequest) {
  // リクエストに対する処理を行う
  // ...

  // レスポンスを返す
  return NextResponse.next()
}
```

このように、`middleware.ts` ファイルにMiddlewareを定義することで、Webアプリケーションの動作をカスタマイズすることができます。




# Example

```middleware.ts
import { NextResponse } from 'next/server'
import type { NextRequest } from 'next/server'

// middleware関数は、`await`を使用している場合は`async`を付けることができます。
export function middleware(request: NextRequest) {
  return NextResponse.redirect(new URL('/home', request.url))
}

// マッチするリクエストを設定します
export const config = {
  matcher: '/about/:path*',
}

```

このコードは、`/about/:path*`にマッチするリクエストがあった場合に、`/home`にリダイレクトするMiddleware関数を定義しています。

具体的には、`middleware`関数内で、`NextResponse.redirect`メソッドを使用して、リダイレクト先のURLを指定しています。

```
NextResponse.redirect(new URL('/home', request.url))

```

request.urlは、クライアントから送信されたリクエストのURLを表します。つまり、サーバーに送信されたリクエストのURLです。

例
aboutページにアクセスした場合
http://localhost:3000/about?lang=ja
↓
homeページにリダイレクトします。
http://localhost:3000/home?lang=ja

?lang=ja ＜＜この部分はクエリパラメータで
このクエリパラメータ部分は **書き換え後** も維持されています。

このMiddleware関数は、`export`されているため、他のファイルからインポートして使用することができます。また、`config`オブジェクトを定義することで、このMiddleware関数をどのようなリクエストに対して適用するかを設定することができます。



# configオブジェクト

middwareではconfigオブジェクトを設定しておけば、自動的に読み込んでくれます。

例えば、

```
    /*
     * Match all request paths except for the ones starting with:
     * - api (API routes)
     * - _next/static (static files)
     * - _next/image
     * - assets
     * - favicon.ico (favicon file)
     * - sw.js (Service Worker file)
     */
  matcher: ["/((?!api|_next/static|_next/image|assets|favicon.ico|sw.js).*)"]

```



このようにマッチャーを設定しておけば、自動的に読み込んでくれて、このパスにマッチしない（?!（否定先読み）記号を利用しているため）パスに対して処理を行います。



# Matching Paths

マッチングパス

Middlewareは、プロジェクト内のすべてのルートに対して起動されます。
Next.jsでは1－8までがすべてのルートに相当します。

Middlewareが動く順番は、まず最初に1から8の順にルートを見ていきます。
そのルートがMiddlewareのmatcherに一致した場合、 Middleware内のコードが実行されます。

実行順序は以下の通りです：
1－8までがNext.jsのすべてのルートに相当します。

1. next.config.jsからのヘッダー
2. next.config.jsからのリダイレクト
3. Middleware（リライト、リダイレクトなど）
4. next.config.jsからのbeforeFiles（リライト)
5. ファイルシステムのルート（public/、_next/static/、pages/、app/など）
6. afterFiles (next.config.jsから書き換え)
7. 動的ルート (/blog/[slug])
8. fallback（next.config.jsからの書き換え)

`8 fallback` は、`matcher` に対応するパスが存在しなかった場合に行う処理です。
つまり、`1-7` にマッチしないパスはすべて `8. fallback` が処理を行います。
`8 fallback` は、アルゴリズム番兵法の番兵のようなものと言えます。



まず、リダイレクト処理はmiddlewareの役割というよりも、next.config.js に書いていました。
(middleware は Next.js v12からβ版が追加されました。)

だからまずnext.config.jsでリダイレクトを処理して、次にMiddlewareが処理するという流れになっています。

なので、↑2 のnext.config.jsを使ったパスがマッチして、リダイレクトが行われた場合、
↑3 のmiddleware より下位にあるパスは無視されます。



# 参考 next.config.jsを使ったリダイレクト

【Next.js】App Routerでのリダイレクトを模索した

https://zenn.dev/fujiyama/articles/97426362f6c84c



next.config.jsで出来るリダイレクト
パス
Header
Cookie

middleware v13.0 から redirect() という関数が使えます。
この redirect() はServer Components、 Client Componentsの両方で使えます。

```
import { redirect } from 'next/navigation'

```





# パスの定義

Middlewareが実行されるパスを定義するには、2つの方法があります：

1. カスタムマッチャー構成
2. 条件文



## 1. カスタムマッチャー構成

### Matcher

matcher を使用すると、特定のパスで実行するミドルウェアをフィルタリングできます。

一番シンプルな例

```middleware.js
export const config = {
  matcher: '/about/:path*',
}

```



配列で、単一のパスまたは複数のパスにマッチさせることができます。

複数のマッチングが可能

```middleware.js
export const config = {
  matcher: ['/about/:path*', '/dashboard/:path*'],
}

```



matcher configでは正規表現が使用できます。

```middleware.js
    /*
     * Match all request paths except for the ones starting with:
     * - api (API routes)
     * - _next/static (static files)
     * - _next/image (image optimization files)
     * - assets (assets files)
     * - favicon.ico (favicon file)
     * - sw.js (Service Worker file)
     */
export const config = {
  matcher: ["/((?!api|_next/static|_next/image|assets|favicon.ico|sw.js).*)"]
}

```



例えば、`matcher`プロパティには、リクエストに対してマッチするパスを指定することができます。

この例では、`/((?!api|_next/static|_next/image|assets|favicon.ico|sw.js).*)`という正規表現を使用して、

`api`			(API routes)
`_next/static`	(static files)
`_next/image`	(image optimization files)
`assets`		(assets files)
`favicon.ico`	(favicon file)
`sw.js`			(Service Worker file)
これ以外のすべてのリクエストに対してマッチします。



#### Tips

マッチャーの値は、ビルド時に静的に解析できるように定数が好ましいです。動的な値は無視されます。



### Configured matchers:

URLパスのマッチングに関するルール

- パスは`/`で始まる必要があります。

- 名前付きパラメータを含むことができます。たとえば、`/about/:path`は`/about/a`と`/about/b`にマッチしますが、`/about/a/c`にはマッチしません。

- 名前付きパラメータには、修飾子を付けることができます。たとえば、`/about/:path*`は、`/about/a/b/c`にもマッチします。`*`は0回以上の繰り返しを表します。`?`は0回または1回の繰り返しを表します。`+`は1回以上の繰り返しを表します。

- 正規表現を使用することができます。たとえば、`/about/(.*)`は、`/about/:path*`と同じように動作します。

これらのルールを使用することで、URLパスに対する柔軟なマッチングを実現することができます。

名前付きパラメータを使用する場合には、パラメータ名が一意であることが必要です。

pillarjs/path-to-regexp: Turn a path string such as `/user/:name` into a regular expression

https://github.com/pillarjs/path-to-regexp#path-to-regexp-1

↑正規表現のルール



#### Tips

後方互換性のため、Next.jsは常に/publicを/public/indexとみなします。
したがって、/public/:pathのマッチャーはマッチします。



## 2. 条件文

Conditional Statements

```middleware.ts
import { NextResponse } from 'next/server'
import type { NextRequest } from 'next/server'

export function middleware(request: NextRequest) {
  if (request.nextUrl.pathname.startsWith('/about')) {
    return NextResponse.rewrite(new URL('/about-2', request.url))
  }

  if (request.nextUrl.pathname.startsWith('/dashboard')) {
    return NextResponse.rewrite(new URL('/dashboard/user', request.url))
  }
}

```

リクエストに対して条件文で2種類のURLの書き換えを行っています。

具体的には、middleware関数は、requestオブジェクトを受け取り、if文でリクエストされたURLのパスに応じて、URLの書き換えを行っています。

/aboutで始まるパスの場合は、/about-2に書き換え、
/dashboardで始まるパスの場合は、/dashboard/userに書き換えています。

URLの書き換えには、NextResponse.rewriteメソッドを使用しています。

このメソッドは、引数に書き換え後のURLを指定することで、リクエストされたURLを書き換えることができます。





# NextResponse

Next.jsの`NextResponse` APIについて以下のような機能があります。

- リダイレクト：リクエストを別のURLにリダイレクトすることができます。

- レスポンスの書き換え：指定されたURLを表示することで、レスポンスを書き換えることができます。

- リクエストヘッダーの設定：APIルート、getServerSideProps、および書き換え先に対してリクエストヘッダーを設定することができます。

- レスポンスクッキーの設定：レスポンスにクッキーを設定することができます。

- レスポンスヘッダーの設定：レスポンスにヘッダーを設定することができます。

Middlewareからレスポンスを生成する方法としては、以下の2つがあります。

- ルート（ページまたはルートハンドラー）に書き換えて、レスポンスを生成する。

- `NextResponse`オブジェクトを直接返します。
詳細については、ここより↓にある`Producing a Response`を参照してください。



Routing: Pages and Layouts | Next.js

https://nextjs.org/docs/app/building-your-application/routing/pages-and-layouts

Routing: Route Handlers | Next.js

https://nextjs.org/docs/app/building-your-application/routing/route-handlers



# Using Cookies

クッキーは、リクエストのCookieヘッダーまたはレスポンスのSet-Cookieヘッダーに格納されます。

リクエストのCookieヘッダー
クライアントからサーバーに送信されるHTTPリクエストに含まれるヘッダーの一つで、クライアントがサーバーに送信するクッキー情報を含んでいます。

レスポンスのSet-Cookieヘッダー
サーバーからクライアントに送信されるHTTPレスポンスに含まれるヘッダーの一つで、サーバーがクライアントに送信するクッキー情報を含んでいます。

Set-Cookieヘッダーには、クッキーの有効期限、ドメイン、パス、セキュア属性などの情報を含めることができます。

クッキー情報は、名前と値のペアで構成され、Webサイトの訪問履歴やログイン情報などを保存するために使用されます。



Next.jsでは、`NextRequest`と`NextResponse`の拡張機能を使用して、クッキーを簡単にアクセスおよび操作することができます。



```middleware.ts
import { NextResponse } from "next/server"
import type { NextRequest } from "next/server"

export function middleware(request: NextRequest) {
  // "Cookie:nextjs=fast"ヘッダーが受信リクエストに存在すると仮定する
  // RequestCookies APIを使用してリクエストからクッキーを取得する
  let cookie = request.cookies.get("nextjs")
  console.log(cookie) // => { name: 'nextjs', value: 'fast', Path: '/' }
  const allCookies = request.cookies.getAll()
  console.log(allCookies) // => [{ name: 'nextjs', value: 'fast' }]

  request.cookies.has("nextjs") // => true
  request.cookies.delete("nextjs")
  request.cookies.has("nextjs") // => false

  // `ResponseCookies` APIを使用してレスポンスにクッキーを設定する
  const response = NextResponse.next()
  response.cookies.set("vercel", "fast")
  response.cookies.set({
    name: "vercel",
    value: "fast",
    path: "/",
  })
  cookie = response.cookies.get("vercel")
  console.log(cookie) // => { name: 'vercel', value: 'fast', Path: '/' }
  // ja: 出力レスポンスには `Set-Cookie:vercel=fast;path=/test` ヘッダーが含まれます。

  return response
}

```

↑このコードには、
リクエストからクッキーを取得する方法
レスポンスにクッキーを設定する方法
が書かれています。



- リクエストからクッキーを操作する方法は
`request.cookies.get`メソッドを使用して、クッキーの値を取得することができます。
`request.cookies.getAll`メソッドを使用して、すべてのクッキーを取得することができます。
`request.cookies.has`メソッドを使用して、クッキーが存在するかどうかを確認します。
`request.cookies.delete`メソッドを使用して、クッキーを削除します。



- レスポンスにクッキーを設定する場合は
`response.cookies.set`メソッドを使用して、クッキーを設定します。
また、オブジェクトを渡すことで、複数のクッキーを一度に設定することもできます。
`response.cookies.get`メソッドを使用して、設定されたクッキーの値を取得します。





# Setting Headers

リクエストヘッダとレスポンスヘッダは、NextResponse APIで設定できます。
（リクエストヘッダの設定はNext.js v13.0.0から）



```middleware.ts
import { NextResponse } from "next/server"
import type { NextRequest } from "next/server"

export function middleware(request: NextRequest) {
  // リクエストヘッダーをクローンし、新しいヘッダー `x-hello-from-middleware1` を設定します。
  const requestHeaders = new Headers(request.headers)
  requestHeaders.set("x-hello-from-middleware1", "hello")

  // NextResponse.rewrite でもリクエストヘッダーを設定できます。
  const response = NextResponse.next({
    request: {
      // 新しいリクエストヘッダー
      headers: requestHeaders,
    },
  })

  // 新しいレスポンスヘッダー `x-hello-from-middleware2` を設定します。
  response.headers.set("x-hello-from-middleware2", "hello")
  return response
}

```



↑このコードは、Next.jsでリクエストとレスポンスのヘッダーを設定する方法です。



1. `Headers`オブジェクトを使用して、リクエストヘッダーをクローンし、新しいヘッダーを設定します。`request.headers`からヘッダーを取得し、`requestHeaders.set`メソッドを使用して、新しいヘッダーを設定します。

2. `NextResponse.next`メソッドを使用して、新しいレスポンスを作成します。このとき、`request`オプションを使用して、新しいリクエストヘッダーを設定することができます。`requestHeaders`を使用して、新しいヘッダーを設定します。

3. `response.headers.set`メソッドを使用して、新しいレスポンスヘッダーを設定します。
クローン
オブジェクトをクローンするとは、元のオブジェクトと同じプロパティを持つ新しいオブジェクトを作成することです。
元のオブジェクトと新しいオブジェクトは、別々のメモリ領域に保存されます。
クローンすることで、元のオブジェクトを変更しても、新しいオブジェクトには影響がなくなります。

このコードでは、`Headers`オブジェクトをクローンして、新しいヘッダーを設定しています。`Headers`オブジェクトは、HTTPリクエストやレスポンスのヘッダーを表すオブジェクトです。
`Headers`オブジェクトをクローンすることで、元のリクエストヘッダーを変更することなく、新しいヘッダーを設定することができます。

注意点としては、ヘッダーのサイズが大きすぎる場合、バックエンドのWebサーバーの設定によっては、431 Request Header Fields Too Largeエラーが発生する可能性があることです。また、ヘッダーにはセキュリティ上の問題があるため、機密情報を含めないようにする必要があります。

この方法の長所は、リクエストとレスポンスのヘッダーを柔軟に設定できることです。

例えば、認証トークンをリクエストヘッダーに設定することで、APIの認証を行うことができます。
また、レスポンスヘッダーには、キャッシュ制御やセキュリティ関連の情報を設定することができます。

この方法は、APIの認証やキャッシュ制御、セキュリティ関連の情報を設定する場合に使用することができます。
また、リクエストとレスポンスのヘッダーを柔軟に設定することができるため、様々な用途に応用することができます。

※バックエンドのウェブサーバーの設定によっては、431 Request Header Fields Too Large エラーが発生する可能性があります。



# Producing a Response

ResponseまたはNextResponseインスタンスを返すことで、Middlewareから直接応答できます。(これはNext.js v13.1.0から利用可能です。)



```middleware.ts
import { NextRequest, NextResponse } from 'next/server'
import { isAuthenticated } from '@lib/auth'

// Limit the middleware to paths starting with `/api/`
export const config = {
  matcher: '/api/:function*',

}

export function middleware(request: NextRequest) {

  // Call our authentication function to check the request

  if (!isAuthenticated(request)) {

    // Respond with JSON indicating an error message

    return new NextResponse(
      JSON.stringify({ success: false, message: 'authentication failed' }),
      { status: 401, headers: { 'content-type': 'application/json' } }
    )
  }
}

```



↑このコードは、Next.jsでMiddlewareから直接レスポンスを返す方法です。

1. `config`オブジェクトを使用して、Middlewareを`/api/`で始まるパスに制限します。
これにより、このMiddlewareは`/api/`で始まるパスにのみ適用されます。

2. `isAuthenticated`関数を使用して、リクエストが認証されているかどうかを確認します。
認証に失敗した場合は、エラーメッセージを含むJSONレスポンスを返します。

3. `NextResponse`クラスを使用して、新しいレスポンスを作成します。
`NextResponse`クラスは、`body`と`options`の2つの引数を受け取ります。

`body`はレスポンスの本文を表します。
`options`はレスポンスのオプションを表します。

このコードでは、`body`にJSON文字列を、`options`にステータスコードとヘッダーを設定しています。

この方法の長所は、Middlewareから直接レスポンスを返すことができるため、APIの認証やエラーハンドリングなど、様々な用途に応用することができます。

また、`NextResponse`クラスを使用することで、レスポンスの本文やヘッダーを柔軟に設定することができます。

一方、短所としては、レスポンスを直接返すため、後続のMiddlewareやハンドラーが実行されないことがあることが挙げられます。また、レスポンスの本文やヘッダーを直接設定するため、コードが複雑になる可能性があることもあります。

この方法は、APIの認証やエラーハンドリングなど、Middlewareから直接レスポンスを返す必要がある場合に使用することができます。また、`NextResponse`クラスを使用することで、レスポンスの本文やヘッダーを柔軟に設定することができます。



# Advanced Middleware Flags

Next.jsのv13.1では、高度なユースケースに対応するために、

skipTrailingSlashRedirect
skipMiddlewareUrlNormalize

という2つの追加フラグがMiddlewareに導入されました。

これにより、直接アクセスとクライアント側の遷移を同じように扱うことができない場合に、元のURLを使用することができます。



## skipTrailingSlashRedirect

Next.jsのデフォルトのリダイレクトを無効にして、末尾のスラッシュを追加または削除します。

※トレーリングスラッシュ
URLの末尾に付くスラッシュのことです。
例えば、`https://example.com/path/`のように、末尾にスラッシュが付いている場合があります。
トレーリングスラッシュが付いているかどうかによって、同じページでも異なるURLとして扱われることがあります。



```next.config.js
module.exports = {
  skipTrailingSlashRedirect: true,
}

```

```middleware.js
const legacyPrefixes = ['/docs', '/blog']

export default async function middleware(req) {
  const { pathname } = req.nextUrl

  if (legacyPrefixes.some((prefix) => pathname.startsWith(prefix))) {
    return NextResponse.next()
  }

  // apply trailing slash handling
  if (
    !pathname.endsWith('/') &&
    !pathname.match(/((?!\.well-known(?:\/.*)?)(?:[^/]+\/)*[^/]+\.\w+)/)
  ) {
    req.nextUrl.pathname += '/'
    return NextResponse.redirect(req.nextUrl)
  }
}

```

↑このコードは、Next.jsのMiddlewareを使用して、トレーリングスラッシュの処理をカスタマイズする方法を示しています。

1. `skipTrailingSlashRedirect`フラグを使用して、Next.jsのデフォルトのリダイレクトを無効にします。
これにより、Middleware内でカスタムな処理を行うことができます。例えば、一部のパスにはトレーリングスラッシュを付け、他のパスには付けないようにすることができます。これにより、徐々に移行することができます。

2. `middleware`関数を定義し、`req`オブジェクトから`pathname`を取得します。

3. `legacyPrefixes`配列に含まれるパスの場合は、`NextResponse.next()`を返して、後続のMiddlewareやハンドラーが実行されるようにします。

4. トレーリングスラッシュの処理を行います。`pathname`がスラッシュで終わっていない場合、かつ`.well-known`で始まるパスでない場合は、`req.nextUrl.pathname`にスラッシュを追加して、`NextResponse.redirect()`を返します。これにより、トレーリングスラッシュが付いたURLにリダイレクトされます。

この方法の長所は、Middlewareでより柔軟なトレーリングスラッシュの処理を行うことができることです。例えば、一部のパスにはトレーリングスラッシュを付け、他のパスには付けないようにすることができます。

また、`skipTrailingSlashRedirect`フラグを使用することで、Next.jsのデフォルトの挙動から外れることができます。

一方、短所としては、トレーリングスラッシュの処理をカスタマイズするため、コードが複雑になる可能性があることが挙げられます。

この方法は、トレーリングスラッシュの処理をカスタマイズする必要がある場合に使用することができます。例えば、一部のパスにはトレーリングスラッシュを付け、他のパスには付けないようにすることができます。また、`skipTrailingSlashRedirect`フラグを使用することで、Next.jsのデフォルトの挙動から外れることができます。ただし、トレーリングスラッシュの処理をカスタマイズする場合は、コードが複雑になる可能性があることに注意する必要があります。



## skipMiddlewareUrlNormalize

Next.jsが行うURL正規化を無効にし、直接訪問とクライアント遷移の処理を同じにします。
元のURLを使用して完全に制御する必要がある高度なケースもありますが、そのような場合はこの機能を利用できます。


```next.config.js
module.exports = {
  skipMiddlewareUrlNormalize: true,
}

```



```middleware.js
export default async function middleware(req) {
  const { pathname } = req.nextUrl

  // GET /_next/data/build-id/hello.json

  console.log(pathname)
  // with the flag this now /_next/data/build-id/hello.json
  // without the flag this would be normalized to /hello
}

```



↑このコードは、Next.jsのMiddlewareを使用して、URLの正規化処理をカスタマイズする方法です。

1. `skipMiddlewareUrlNormalize`フラグを使用して、Next.jsがURLを正規化する処理を無効にします。
これにより、直接アクセスとクライアント側の遷移を同じように扱うことができない場合に、元のURLを使用することができます。

2. `middleware`関数を定義し、`req`オブジェクトから`pathname`を取得します。

3. `console.log()`を使用して、`pathname`を出力します。
`skipMiddlewareUrlNormalize`フラグを使用している場合、`pathname`は正規化されずにそのまま出力されます。
一方、フラグを使用していない場合は、`pathname`が正規化されてしまい、元のURLと異なる場合があります。

この方法の長所は、URLの正規化処理をカスタマイズすることができることです。
例えば、直接アクセスとクライアント側の遷移を同じように扱うことができない場合に、元のURLを使用することができます。

一方、短所としては、フラグを使用することで、Next.jsのデフォルトの挙動から外れるため、予期しない動作を引き起こす可能性があることが挙げられます。
また、フラグを使用することで、コードが複雑になる可能性があることもあります。

この方法は、URLの正規化処理をカスタマイズする必要がある場合に使用することができます。ただし、フラグを使用する場合は、予期しない動作に注意する必要があります。


# Middleware version History

| Version | Changes |
|---------|---------|
| v13.1.0 | Advanced Middleware flags added |
| v13.0.0 | Middleware can modify request headers, response headers, and send responses |
| v12.2.0 | Middleware is stable, please see the upgrade guide |
| v12.0.9 | Enforce absolute URLs in Edge Runtime (PR) |
| v12.0.0 | Middleware (Beta) added |

v13.0.0
Middlewareはリクエスト ヘッダー、レスポンス ヘッダーを変更し、レスポンスを送信できます。







# 参考

Next.jsで複数のmiddlewareの関数を連結させる

https://zenn.dev/hayato94087/articles/8f6496e0b8936f

hayato94087/nextjs-middleware-chain-sample

https://github.com/hayato94087/nextjs-middleware-chain-sample

Chain Multiple Middleware Functions in NextJs 13 - YouTube

https://www.youtube.com/watch?v=fmFYH_Xu3d0





# path 判定の Tips

↓現在位置が/aboutであるという判断に使用します。

req.nextUrl.pathname === "/about"

↓現在位置が/aboutかもしくはその下であるという判断に使用します。

req.nextUrl.pathname === "/about/*"

↓pathの始まりが/aboutで始まっているかどうかの判断に使用します。

request.nextUrl.pathname.startsWith('/about')

↓動的フォルダ以下であるかどうかの判断 (プレースホルダー)
matcher: '/:lng*'

"*" 記号はワイルドカード(≒正規表現)です、0回以上の繰り返しにマッチします。