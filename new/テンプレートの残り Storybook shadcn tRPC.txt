






## Storybook のインストール

npx storybook@latest init

インストールが完了すると 自動で Storybook のチュートリアルが始まるので体験してみてください。英語ですが始めてStorybookを触る人にとって最初に知っておくべき重要なことが約3分で知ることができます。

TailwindCSS を Storybook でも適用されるように設定します。

```.storybook/preview.ts (追記)
import "../src/styles/globals.css"

```


# Storybook のインストール直後

'aria-query' の型定義ファイルが見つかりません。
というエラーが出たので対処します。

npm install aria-query

tsconfig.jsonファイルに、
"types": ["aria-query"] を追記します。

```tsconfig.json
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./src/*"]
    },
    "types": ["aria-query"]
  },

```




※Storybookは実際にどんなコンポーネントを作るか決めてから
それで迷ったら導入したほうが良かった
全体像をどうするかもまだ何も決まってない段階では必要なかった。
最初に１つ目のコンポーネントを作るまでは導入しないでいいと思う。









# shadcn/ui

Next.js - shadcn/ui

https://ui.shadcn.com/docs/installation/next

React の UI コンポーネントなら@shadcn/ui がちょうどいい

https://zenn.dev/mottox2/articles/react-shadcn-ui

コンポーネントは CLI からインストールする方法と
サイトからコードをコピーするやり方があります。

shadcn/ui 公式の推奨 Next.js アプリの構成

```tree
src
├── app
│   ├── layout.tsx
│   └── page.tsx
├── components
│   ├── ui
│   │   ├── alert-dialog.tsx
│   │   ├── button.tsx
│   │   ├── dropdown-menu.tsx
│   │   └── ...
│   ├── main-nav.tsx
│   ├── page-header.tsx
│   └── ...
├── lib
│   └── utils.ts
├── styles
│   └── globals.css
├── next.config.js
├── package.json
├── postcss.config.js
├── tailwind.config.js
└── tsconfig.json

```








セットアップ 初期化

ui や utils のコンポーネント保存フォルダを作っておきます。

mkdir src\components\ui

mkdir src\lib

npx shadcn-ui@latest init

globals.cssのインストール場所は指定します。

src/styles/globals.css

その他は全てデフォルト値を選択します。

```
npx shadcn-ui@latest init
√ Would you like to use TypeScript (recommended)? ... no / yes
√ Which style would you like to use? » Default
√ Which color would you like to use as base color? » Slate
√ Where is your global CSS file? ... src/styles/globals.css
√ Would you like to use CSS variables
for colors? ... no / yes
√ Where is your tailwind.config.js located? ... tailwind.config.js
√ Configure the import alias for components: ... @/components
√ Configure the import alias for utils: ... @/lib/utils
√ Are you using React Server Components? ... no / yes
√ Write configuration to components.json. Proceed? ... yes

✔ Writing components.json...
✔ Initializing project...
✔ Installing dependencies...

Success! Project initialization completed.

```

※VSCodeを再起動します。




```shadcn-u インストールのまとめ
初期化
npx shadcn-ui@latest init

※初期化コマンドは既存設定ファイルがある場合上書きされます。
※インストールコマンドと一緒です。

CLI からのコンポーネントインストール方法
npx @shadcn/ui add

npx @shadcn-ui add [options] [components...]

※addコマンドは既存コンポーネントファイルがあっても上書きされます。(確認)


options:
  -y, --yes          skip confirmation prompt. (default: false)
  -o, --overwrite    overwrite existing files. (default: false)
  -c, --cwd <cwd>    the working directory. defaults to the current directory.
  -p, --path <path>  the path to add the component to.
  -h, --help         display help for command

```



上下キーでカーソルが上下します。
スペースで選択します。
リターンキーで決定します。

```shadcn/uiコンポーネントリスト
components:
( )   accordion
( )   alert
( )   alert-dialog
( )   aspect-ratio
( )   avatar
( )   badge
( )   button
( )   calendar
( )   card
( )   checkbox
( )   collapsible
( )   command
( )   context-menu
( )   dialog
( )   dropdown-menu
( )   hover-card
( )   input
( )   label
( )   menubar
( )   navigation-menu
( )   popover
( )   progress
( )   radio-group
( )   scroll-area
( )   select
( )   separator
( )   sheet
( )   skeleton
( )   slider
( )   switch
( )   table
( )   tabs
( )   textarea
( )   toast
( )   toggle
( )   tooltip

インストールするコンポーネントを選択します。
A ですべてを選択します。

※しかし、すべて選択してインストールするとエラーになりました。

```

このコマンドを実行すると、インストールするコンポーネントを選択できるようになります。

2023年7月26日現在 選択できるコンポーネント
※開発が活発なのでこのリスト以外にも増えている可能性があります。


インストール先を指定します。
src/components/ui
src/components/ui
src/components/ui



※デフォルトでは すでにファイルがあると上書きされません。
上書きしたい場合は -o オプションをつけます。





## お試し

button コンポーネントをインストールしてみます。

npx shadcn-ui@latest add button

or

npx shadcn-ui@latest add
button を選択します。

インストール先を指定します。
src/components/ui
src/components/ui



動作確認用

なにか適当なページを作成します。

mkdir src\app\about

touch src\app\about\page.tsx

```src\app\about\page.tsx
"use client";

// import文の順番も自動整形されます。
import { type NextPage } from "next";
import Link from "next/link";

import { Button } from "@/components/ui/button";

const Home: NextPage = () => {
  return (
    <main>
      {/* TailwindCSSのプロパティ値も自動整列されます。 */}
      <h1 className="p-4 pt-2">VNS.BLUE</h1>
      Next.js app router 開発用テンプレート (Storybook Supabase shadcn/ui)
      <br />
      {/* ↓この行を消すとimport文が自動削除されます。 */}
      <Link href="/">Home</Link>
      <div>
        <Button>shadcn/ui の Button</Button>
      </div>
    </main>
  );
};

export default Home;

```

ボタンは RSCでは クライアントコンポーネントにする必要があるので
ディレクティブ
"use client"
を先頭行につけます。

そして
npm run dev
を実行して

http://localhost:3000/about
にアクセスするとボタンが表示されます。





















































































----------------------------------------












# ダークモード

shadcn/ui 公式ドキュメント

Dark Mode - shadcn/ui

https://ui.shadcn.com/docs/dark-mode



# Next.js ＋ shadcn/ui ダークモード

## はじめに - shadcn/ui

https://ui.shadcn.com/docs


## インストール - shadcn/ui

https://ui.shadcn.com/docs/installation



globals.css ファイルを読み込んでいるファイルの path を修正します。

```src\app\layout.tsx
import '@/styles/globals.css'

...

<html lang='ja'>

```

ja と日本語にも設定しておきます。

## shadcn の初期化

npx shadcn-ui@latest init

global CSS のファイルの場所を指定します。

src/styles/globals.css

初期化が終了すると、components.json というファイルが作成されます。

```components.json
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "default",
  "rsc": true,
  "tsx": true,
  "tailwind": {
    "config": "tailwind.config.js",
    "css": "src/styles/globals.css",
    "baseColor": "slate",
    "cssVariables": true
  },
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils"
  }
}

```

## ソース構造（参考）

```tree
src
├── app
│   ├── layout.tsx
│   └── page.tsx
├── components
│   ├── ui
│   │   ├── alert-dialog.tsx
│   │   ├── button.tsx
│   │   ├── dropdown-menu.tsx
│   │   └── ...
│   ├── main-nav.tsx
│   ├── page-header.tsx
│   └── ...
├── lib
│   └── utils.ts
├── styles
│   └── globals.css
├── next.config.js
├── package.json
├── postcss.config.js
├── tailwind.config.js
└── tsconfig.json

```

- UI コンポーネントは components/ui フォルダに配置しています。

- <PageHeader />や<MainNav />などの残りのコンポーネントは、components フォルダに配置します。

- lib フォルダにはすべてのユーティリティ関数が入っています。utils.ts には cn ヘルパーを定義しています。

- styles フォルダにはグローバル CSS が入っています。



## ボタンを追加してみる

コンポーネントのインストール

npx shadcn-ui@latest add

button コンポーネントを選択します。

インストール場所

src\components\ui

インストールされたファイル

src\components\ui\button.tsx

ボタンを表示するコンポーネントを作成します。

※適当なフォルダを作成後↓page.tsxを作成します。

```.....\page.tsx
// import文の順番も自動整形されます。
import { type NextPage } from "next";
import Link from "next/link";

import { Button } from "@/components/ui/button";

const Home: NextPage = () => {
  return (
    <main>
      {/* TailwindCSSのプロパティ値も自動整列されます。 */}
      <h1 className="p-4 pt-2">VNS.BLUE</h1>
      Next.js app router 開発用テンプレート (Storybook Supabase shadcn/ui)
      <br />
      {/* ↓この行を消すとimport文が自動削除されます。 */}
      <Link href="/">Home</Link>
      <div>
        <Button>shadcn/ui の Button</Button>
      </div>
      <br />
      <Link href="./ModeTogglePage">ModeTogglePage</Link>
    </main>
  );
};

export default Home;

```

ボタンコンポーネントテストページ

```src\app\ButtonTestPage\page.tsx
import { Button } from "@/components/ui/button"

export default function Home() {
  return (
    <div>
      <Button>Click me</Button>
    </div>
  )
}

```

```components.json
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "default",
  "rsc": true,
  "tsx": true,          ＜＜＜ TypeScriptを使う場合はtrue
  "tailwind": {
    "config": "tailwind.config.js",
    "css": "src/styles/globals.css",
    "baseColor": "slate",
    "cssVariables": true
  },
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils"
  }
}

```



## Theming テーマ設定

Theming - shadcn/ui

https://ui.shadcn.com/docs/theming

テーマ設定に CSS 変数 または TailwindCSS を使用します。

CSS 変数を使用します、
もしくは
Tailwind CSS の ユーティリティクラス を使用するかを選択できます。

↓ ユーティリティクラス の例

<div className="bg-zinc-950 dark:bg-white" />

ユーティリティクラス を使用する場合の設定



```components.json
{
  "style": "default",
  "rsc": true,
  "tailwind": {
    "config": "tailwind.config.js",
    "css": "app/globals.css",
    "baseColor": "slate",
    "cssVariables": false    ＜＜＜ false に設定します。
  },
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils"
  }
}

```

CSS 変数 の例

<div className="bg-background text-foreground" />

CSS 変数 を使用する場合の設定

```components.json
{
  "style": "default",
  "rsc": true,
  "tailwind": {
    "config": "tailwind.config.js",
    "css": "app/globals.css",
    "baseColor": "slate",
    "cssVariables": true    ＜＜＜ true に設定します。
  },
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils"
  }
}

```



### Convention 規約

色に関しては、シンプルな背景と前景のコンベンションを使用しています。
前景変数はテキスト色に使用されます。
背景変数はコンポーネントの背景色に使用されます。

変数がコンポーネントの背景色に使用される場合、背景接尾辞は省略されます。

例えば、--primary-background という変数は、コンポーネントの背景色に使用する場合は、--primary として省略して使用することができます。

例えば、次のような CSS 変数が与えられます。

--primary: 222.2 47.4% 11.2%;
--primary-foreground: 210 40% 98%;

※ --primary-background は省略され--primary になっています。

--primary とは？
「--primary」は、カスタマイズ可能な CSS 変数の一つで、プロジェクトで使用される主要な色を表します。
この変数は、コンポーネントの背景色やテキスト色など、プロジェクト内の様々な要素の色に使用されます。
例えば、以下のようにして「--primary」変数を使用して、背景色が変更された div 要素を作成することができます。

```
div {
  background-color: var(--primary);
}
```

「The background suffix」とは、前述の通り、背景色に使用される CSS 変数名において、接尾辞として使用される文字列のことを指します。例えば、変数名が「--primary」である場合、背景色に使用する場合は「--primary」とだけ指定し、接尾辞は省略されます。一方、テキスト色に使用する場合は、変数名に「-foreground」などの接尾辞を付けることが一般的です。このように、接尾辞を使用することで、変数名からどのような色が使用されるかを容易に理解することができます。

↑↑ 先程の ↓ この数値は

--primary: 222.2 47.4% 11.2%;
--primary-foreground: 210 40% 98%;

このように使われます。

<div className="bg-primary text-primary-foreground">Hello</div>

このコンポーネントの背景色は hsl(var(--primary))、
前景色は hsl(var(--primary-foreground))となります。

CSS 変数の値は、HSL 色空間で定義されています。HSL 色空間は、色相（Hue）、彩度（Saturation）、明度（Lightness）の 3 つの値を使用して色を表現します。HSL 色空間は、RGB 色空間よりも直感的に理解しやすいため、CSS 変数の値を HSL 色空間で定義しています。

HSL とは
HSL は、色相（Hue）、彩度（Saturation）、明度（Lightness）の 3 つの値を使用して色を表現する色空間の一つです。

色相は、色の種類を表し、0 度から 360 度までの値で表されます。
彩度は、色の鮮やかさを表し、0%から 100%までの値で表されます。
明度は、色の明るさを表し、0%から 100%までの値で表されます。

例えば、赤色は色相が 0 度、彩度が 100%、明度が 50%となります。

CSS 変数の値を HSL 色空間で定義することで、色相、彩度、明度の値を直接指定することができます。



### List of variables

カスタマイズ可能な CSS 変数の一覧

```
背景色
Default background color of <body />...その他
--background: 0 0% 100%;
--foreground: 222.2 47.4% 11.2%;

薄い色調の背景色
Muted backgrounds such as <TabsList />, <Skeleton /> and <Switch />
--muted: 210 40% 96.1%;
--muted-foreground: 215.4 16.3% 46.9%;

カードの背景色
Background color for <Card />
--card: 0 0% 100%;
--card-foreground: 222.2 47.4% 11.2%;

ユーザーがマウスオーバーしたときに表示される背景色
Background color for popovers such as <DropdownMenu />, <HoverCard />, <Popover />
--popover: 0 0% 100%;
--popover-foreground: 222.2 47.4% 11.2%;

デフォルトのボーダー色
Default border color
--border: 214.3 31.8% 91.4%;

入力フィールドに使用されるボーダー色
Border color for inputs such as <Input />, <Select />, <Textarea />
--input: 214.3 31.8% 91.4%;

プライマリカラー
Primary colors for <Button />
--primary: 222.2 47.4% 11.2%;
--primary-foreground: 210 40% 98%;

セカンダリカラー
Secondary colors for <Button />
--secondary: 210 40% 96.1%;
--secondary-foreground: 222.2 47.4% 11.2%;

ホバーエフェクトなどのアクセントに使用されるカラー
Used for accents such as hover effects on <DropdownMenuItem>, <SelectItem>...etc
--accent: 210 40% 96.1%;
--accent-foreground: 222.2 47.4% 11.2%;

「アクセントカラー」とは、UIの中で特定の要素に対して強調するために使用されるカラーを指します。例えば、ボタンやリンクなどのアクション要素に使用されます。アクセントカラーは、Primary colorsやSecondary colorsとは異なり、UIの中で特定の要素に対して強調するために使用されるため、視覚的に目立つ色が使用されることが多いです。プロジェクトによっては、Primary colorsとSecondary colorsに加えて、アクセントカラーとして「Third colors」を定義する場合があります。

削除やキャンセルなどの破壊的なアクションに使用されるカラー
Used for destructive actions such as <Button variant="destructive">
--destructive: 0 100% 50%;
--destructive-foreground: 210 40% 98%;

フォーカスリングに使用されるカラー
Used for focus ring
--ring: 215 20.2% 65.1%;

フォーカスリングは、ユーザーがキーボードでフォーカスを移動したときに表示される、要素の周りに表示されるリング状のエフェクトです。

要素の角を丸めるために使用されるCSSプロパティ
Border radius for card, input and buttons
--radius: 0.5rem;

カード、入力フィールド、ボタンなどの要素に適用される角丸の半径

```



### 新しい色の追加

新しい色を追加するには、CSS ファイル と tailwind.config.js ファイル に追加する必要があります。



```
app/globals.css
:root {
  --warning: 38 92% 50%;
  --warning-foreground: 48 96% 89%;
}

.dark {
  --warning: 48 96% 89%;
  --warning-foreground: 38 92% 50%;
}

tailwind.config.js
module.exports = {
  theme: {
    extend: {
      colors: {
        warning: "hsl(var(--warning))",
        "warning-foreground": "hsl(var(--warning-foreground))",
      },
    },
  },
}
```

これで、↓ コンポーネントで警告ユーティリティ・クラスを使用できるようになりました。

<div className="bg-warning text-warning-foreground" />

その他のカラーフォーマット
テーマ設定には HSL カラーを使用することをお勧めしますが、お好みにより他のカラーフォーマットを使用することもできます。

rgb、rgba、または hsl カラーの使用に関する詳細は、Tailwind CSS ドキュメントを参照してください。



## ダークモード

Dark Mode - shadcn/ui

https://ui.shadcn.com/docs/dark-mode

### Create a theme provider テーマプロバイダーの作成

#### next-themes

next-themes - npm

https://www.npmjs.com/package/next-themes

デモ画面

https://next-themes-example.vercel.app/

Next.js アプリのテーマを抽象化。

- 2 行のコードで完璧なダークモードを実現
- prefers-color-scheme によるシステム設定
- カラースキームを使ったテーマブラウザ UI
- 読み込み時にフラッシュなし(SSR と SSG の両方)
- タブとウィンドウ間でテーマを同期
- テーマ変更時のフラッシュを無効化
- 特定のテーマにページを強制的に合わせる
- クラスまたはデータ属性セレクタ
- useTheme フック



### インストール

npm install next-themes




#### テーマプロバイダーの作成

touch src\components\theme-provider.tsx

```src\components\theme-provider.tsx
"use client"

import { ThemeProvider as NextThemesProvider } from "next-themes";
import { type ThemeProviderProps } from "next-themes/dist/types";
import * as React from "react";

export function ThemeProvider({ children, ...props }: ThemeProviderProps) {
  return <NextThemesProvider {...props}>{children}</NextThemesProvider>;
}

```



#### ルートレイアウトにラップする

src\app\layout.tsx

```src\app\layout.tsx
import "@/styles/globals.css";
import { ThemeProvider } from "next-themes";
import React from "react";

import type { Metadata } from "next";

export const metadata: Metadata = {
  title: "Create Next App",
  description: "Generated by create next app",
};

/**
 * RootLayoutコンポーネントは、HTMLのルート要素を含むページのレイアウトを定義します。
 * @param {object} props - プロパティオブジェクト
 * @param {React.ReactNode} props.children - 子要素
 * @return {JSX.Element} HTMLのルート要素を含むReact要素
 */
export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="ja" suppressHydrationWarning>
      <body>
        <ThemeProvider attribute="class" defaultTheme="system" enableSystem>
          {children}
        </ThemeProvider>
      </body>
    </html>
  );
}


```

※ suppressHydrationWarning は、React がクライアント側でレンダリングされたコンテンツをハイドレーションすることを抑制するために使用されます。

これで Next.js 13 App Router 使用時にダークモードを使用してもハイドレーションエラーが回避できると報告されています。

【Next.js 13】 next-themes でダークモードを実装する方法 | logsuke

https://logsuke.com/web/programming/react/next-themes



#### テーマを切り替える モードトグルを作成する

npx shadcn-ui@latest add dropdown-menu

src\app\ModeTogglePage\page.tsx ファイルを作ります。


mkdir src\app\ModeTogglePage

touch src\app\ModeTogglePage\page.tsx

```src\app\ModeTogglePage\page.tsx
"use client";

import { Moon, Sun } from "lucide-react";
import { useTheme } from "next-themes";
import * as React from "react";

import { Button } from "@/components/ui/button";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";

export default function ModeToggle() {
  const { setTheme } = useTheme();

  return (
    <DropdownMenu>
      <DropdownMenuTrigger asChild>
        <Button variant="outline" size="default">
          <Sun className="h-[1.2rem] w-[1.2rem] rotate-0 scale-100 transition-all dark:-rotate-90 dark:scale-0" />
          <Moon className="absolute h-[1.2rem] w-[1.2rem] rotate-90 scale-0 transition-all dark:rotate-0 dark:scale-100" />
          <span className="sr-only">Toggle theme</span>
        </Button>
      </DropdownMenuTrigger>
      <DropdownMenuContent align="end">
        <DropdownMenuItem onClick={() => setTheme("light")}>
          Light
        </DropdownMenuItem>
        <DropdownMenuItem onClick={() => setTheme("dark")}>
          Dark
        </DropdownMenuItem>
        <DropdownMenuItem onClick={() => setTheme("system")}>
          System
        </DropdownMenuItem>
      </DropdownMenuContent>
    </DropdownMenu>
  );
}

```

↓トグルボタンをつけてみる

```src\app\page.tsx


      <Link href="./ModeTogglePage">ButtonTestPage</Link>

```

npm run dev

でローカルサーバーを起動して動作確認をします。

http://localhost:3000/ModeTogglePage

切り替えが確認できれば作業は完了です。















# ダークモードの調査

Tailwind CSS を使った ダークモード実装の効率的なアプローチ

https://zenn.dev/deer/articles/d3b104ac97711d

Tailwind CSS のダークモード対応ガイド - snappify.com

https://snappify.com/view/8d426d44-f485-4c62-9bc8-8efe23f558ea

> まとめ
> 以上を踏まえ、冒頭で紹介した CSS 変数と　カスタムカラーを使うアプローチが最適解だという結論に至りました。このアプローチは最近海外で注目を集めている shadcn/ui で知りました。 shadcn/ui をつかうとよくある変数の定義とカスタムカラーの紐付けをプロジェクトに反映することができるので興味のある方は試してみてください。

## ライブラリ next-themes について

next-themes - npm

https://www.npmjs.com/package/next-themes

## 簡単な解説

<html class="dark">

↑ このように HTML に dark クラスを追加すると、
↓ このように TailwindCSS の dark モードが有効になります。

<div className="dark:bg-darkgrey dark:text-white">



## インストール

npm install next-themes

## App Router での利用時の問題点

Next.js 13 appDir support · Issue #152 · pacocoursey/next-themes

https://github.com/pacocoursey/next-themes/issues/152



## shadcn/ui その他

### CLI

CLI - shadcn/ui

https://ui.shadcn.com/docs/cli

(実験的コマンド)

↓ 更新が利用可能なコンポーネントのリストを取得します。

npx shadcn-ui diff

↓ diff [component] コマンドで変更の確認します。

npx shadcn-ui diff alert

### タイポグラフィ 装飾の使い方

タイポグラフィ - shadcn/ui

https://ui.shadcn.com/docs/components/typography

### Figma

@shadcn/ui - Design System – Figma

https://www.figma.com/community/file/1203061493325953101

### 変更履歴

Changelog - shadcn/ui

https://ui.shadcn.com/docs/changelog

例
ベースカラー
gray
neutral
slate
stone
zinc

# shadcn/ui の読み方は？

作者本人のツィート

https://twitter.com/shadcn/status/1647397488742080512

> @shadcn how do i properly pronounce your handle when i'm introducing your projects to others 😅 been saying "shad-see-enn" but idk if that's correct

@shadcn 他の人にあなたのプロジェクトを紹介するとき、あなたのハンドルネームをどう発音すればいいのでしょうか？

> shad as in shadow

シャドウ

シャドウ ユーアイ
シャドウ ユーザーインターフェース

# 参考

【Next.js 13】 next-themes でダークモードを実装する方法 | logsuke

https://logsuke.com/web/programming/react/next-themes

※この記事には、ハイドレーションエラー対策があります。

Next × Stitches × next-themes を使用してダークモード実装

https://zenn.dev/hiro4hiro4/articles/e90778a816df84

Tailwind CSS を使った ダークモード実装の効率的なアプローチ

https://zenn.dev/deer/articles/d3b104ac97711d




































































# tRPC

## インストール

Set up with Next.js | tRPC

https://trpc.io/docs/client/nextjs/setup

npm install @trpc/server @trpc/client @trpc/react-query @tanstack/react-query zod

※ @trpc/next はインストールをしない。


## tRPCが動くようにコードを書く

```src\app\api\trpc\[trpc]\route.ts
import {
  FetchCreateContextFnOptions,
  fetchRequestHandler,
} from "@trpc/server/adapters/fetch";

import { appRouter } from "@/trpc-server";

const handler = (request: Request) => {
  console.log(`incoming request ${request.url}`);
  return fetchRequestHandler({
    endpoint: "/api/trpc",
    req: request,
    router: appRouter,
    createContext: function (
      opts: FetchCreateContextFnOptions,
    ): object | Promise<object> {
      // empty context
      return {};
    },
  });
};

export const GET = handler;
export const POST = handler;

```



```src\app\clientcomponent\page.tsx
import MyRpcClientComponent from "@/app/MyRpcClientComponent";

export default async function Home() {
  return (
    <>
      <MyRpcClientComponent arg={1} />
      <MyRpcClientComponent arg={2} />
      <MyRpcClientComponent arg={3} />
      <MyRpcClientComponent arg={4} />
      <MyRpcClientComponent arg={5} />
    </>
  );
}

```



```src\app\servercomponent\page.tsx
import { appRouter } from "@/trpc-server"

export default async function rscPage() {
  const caller = appRouter.createCaller({})
  const result = await caller.userById(3)
  if (!result) {
    return <p>Not found</p>
  }

  return <p>Hi, {result.name}, greetings from RSC land!</p>
}

```


```src\app\layout.tsx
import "@/styles/globals.css";
import { Metadata } from "next";
import React from "react";

import { TrpcProvider } from "@/app/TrpcProvider";
import { ThemeProvider } from "@/components/theme-provider";

export const metadata: Metadata = {
  title: "Create Next App",
  description: "Generated by create next app",
};

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <TrpcProvider>
      <html lang="ja" suppressHydrationWarning>
        <body>
          <ThemeProvider attribute="class" defaultTheme="system" enableSystem>
            {children}
          </ThemeProvider>
        </body>
      </html>
    </TrpcProvider>
  );
}

```



```src\app\MyRpcClientComponent.tsx
"use client"
import { JSX } from "react";

import { trpc } from "@/trpc"

type MyRpcClientComponentProps = {
  arg: number
}

export default function MyRpcClientComponent(props: MyRpcClientComponentProps): JSX.Element {

  const name = trpc.userById.useQuery(props.arg)

  if (name.data == undefined) {
    console.log("name.data undefined")
    return <p>did not work</p>
  }
  console.log(`result.data is ${JSON.stringify(name.data)}`)

  return <p>Hello, {name.data!.name}, greetings from client component land!</p>
}

```



```src\app\page.tsx
import { type NextPage } from "next";
import Link from "next/link";

import { Button } from "@/components/ui/button";

declare global {
  namespace JSX {
    interface IntrinsicElements {
      [elemName: string]: any;
    }
  }
}

const Home: NextPage = () => {
  return (
    <main>
      <h1 className="p-4 pt-2 text-blue-300">VNS.BLUE</h1>
      <div className="text-green-400">
        Next.js app router 開発用テンプレート (Storybook Supabase shadcn/ui)
      </div>
      <br />
      {/* ↓<Button>タグを消すと<Button>のimport文が自動削除されます。 */}
      <div>
        <Button>shadcn/ui の Button</Button>
      </div>
      <br />
      <Link href="./ModeTogglePage">ModeTogglePage</Link>
      <br />
      <Link href="/servercomponent">リンクボタン:サーバーコンポーネント</Link>
      <br />
      <Link href="/clientcomponent">
        リンクボタン:クライアントコンポーネント
      </Link>
    </main>
  );
};

export default Home;

```


```src\app\TrpcProvider.tsx
"use client"

import { QueryClient, QueryClientProvider } from "@tanstack/react-query"
import { httpBatchLink } from "@trpc/client"
import React from "react";
import { useState } from "react"

import { trpc } from "@/trpc"

export const TrpcProvider: React.FC<{ children: React.ReactNode }> = (p) => {
  const [queryClient] = useState(() => new QueryClient())
  const [trpcClient] = useState(() =>
    trpc.createClient({
      links: [
        httpBatchLink({
          url: "http://localhost:3000/api/trpc",
        }),
      ],
    }),
  )
  return (
    <trpc.Provider client={trpcClient} queryClient={queryClient}>
      <QueryClientProvider client={queryClient}>{p.children}</QueryClientProvider>
    </trpc.Provider>
  )
}

```



```src\trpc-server.ts
import { initTRPC } from "@trpc/server"
import { z } from "zod"

const t = initTRPC.create()

interface User {
  id: string
  name: string
}

const userList: User[] = [
  {
    id: "1",
    name: "VNS.BLUE:1",
  },
  {
    id: "2",
    name: "Masakinihirota:2",
  },
  {
    id: "3",
    name: "シュレディンガーの猫主義:3",
  },
  {
    id: "4",
    name: "アナザーディメンション:4",
  },
  {
    id: "5",
    name: "狂乱索餌:5",
  },
]

export const appRouter = t.router({
  userById: t.procedure.input(z.number()).query((req) => {
    const { input } = req
    return userList.find((u) => parseInt(u.id) === input)
  }),
})

export type AppRouter = typeof appRouter

```

```src\trpc.ts
import { createTRPCReact } from "@trpc/react-query"
import type { AppRouter } from "./trpc-server"
export const trpc = createTRPCReact<AppRouter>()

```





# i18n



































調査中...


[WIP]
これより下は調査中です。

# Storybook の動作確認

npm run storybook

Storybook
http://localhost:6006/

コロケーションパターンで開発するので、
コンポーネントファイルと
ストーリーファイル(SF3)と
テストファイルを同一フォルダ内に入れます。

現在はデフォルトのコンポーネントが stories フォルダに入っています。

## Storybook インタラクションテストの組み込み

Play function

https://storybook.js.org/docs/react/writing-stories/play-function

npm install @storybook/testing-library @storybook/jest @storybook/addon-interactions --save-dev

Storybook の「インタラクションテスト」でフロントエンドのテストをシンプルに管理する！｜ SHIFT Group 技術ブログ

https://note.com/shift_tech/n/n5646b52b3092

インタラクションテストに対応した
コンポーネントと
ストーリーを作成します。

```Button.tsx
import React, { useState } from "react";
import { useRouter } from "next/router";
import "./button.css";

interface ButtonProps {
  testId: string;
  label: string;
  text?: string;
  href?: string;
  primary?: boolean;
  "data-testid"?: string;
}

export const Button = ({
  testId,
  label,
  text,
  href,
  primary = false,
  ...props
}: ButtonProps) => {
  const [textToggle, setTextToggle] = useState(false);
  const router = useRouter();
  const mode = primary ? "primary" : "";

  const onClick = () => {
    if (href) {
      router.push(href);
    } else {
      setTextToggle(!textToggle);
    }
  };

  return (
    <div>
      <button
        data-test-id={testId}
        type="button"
        className={["button", mode].join(" ")}
        onClick={onClick}
        {...props}
      >
        {　label　}
      </button>
      {textToggle && <div>{text}</div>}
    </div>
  );
};

```

```button.css
.button {
  font-family: "Nunito Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
  font-size: 20px;
  font-weight: 700;
  border: 0;
  border-radius: 3em;
  cursor: pointer;
  display: inline-block;
  line-height: 1;
  padding: 10px 20px;
  color: #333;
  background-color: transparent;
  box-shadow: rgba(0, 0, 0, 0.15) 0px 0px 0px 1px inset;
}
.primary {
  color: white;
  background-color: #1ea7fd;
}

```

```Button.stories.ts
import type { Meta, StoryObj } from "@storybook/react";
import { within, userEvent } from "@storybook/testing-library";
import { jest, expect } from "@storybook/jest";

import { Button } from "./Button";

const fn = jest.fn();

const meta: Meta<typeof Button> = {
  title: "Atoms/Button",
  component: Button,
  tags: ["autodocs"],
  parameters: {
    nextjs: {
      router: {
        push: fn,
      },
    },
  },
};

export default meta;
type Story = StoryObj<typeof Button>;

export const Default: Story = {
  args: {
    label: "Default",
    "data-testid": "button",
  },
  play: async ({ canvasElement, step }) => {
    const canvas = within(canvasElement);

    await step("ボタンにLabelの文字列が表示されている", async () => {
      await expect(canvas.getByText("Default")).toBeInTheDocument();
    });
  },
};

export const Primary: Story = {
  args: {
    primary: true,
    label: "Primary",
    "data-testid": "button",
  },
  play: async ({ canvasElement, step }) => {
    const canvas = within(canvasElement);

    await step("ボタンのclassName属性にprimaryが適用されている", async () => {
      const button = canvas.getByTestId("button");
      await expect(button.classList.contains("primary")).toBe(true);
    });
  },
};

export const Toggle: Story = {
  args: {
    label: "Toggle",
    text: "Success",
    "data-testid": "button",
  },
  play: async ({ canvasElement, step }) => {
    const canvas = within(canvasElement);

    await step("ボタン押下でtextを表示する", async () => {
      await userEvent.click(canvas.getByTestId("button"));
      await expect(canvas.getByText("Success")).toBeInTheDocument();
    });

    await step("再度ボタン押下でtextを非表示にする", async () => {
      await userEvent.click(canvas.getByTestId("button"));
      await expect(canvas.queryByText("Success")).toBeNull();
    });
  },
};

export const Link: Story = {
  args: {
    label: "Link",
    href: "/auth/login",
    "data-testid": "button",
  },
  play: async ({ canvasElement, step }) => {
    const canvas = within(canvasElement);

    await step("ボタン押下でhrefで指定した画面に遷移する", async () => {
      await userEvent.click(canvas.getByTestId("button"));
      await expect(fn.mock.lastCall).toContainEqual("/auth/login");
    });
  },
};

```

Storybook のダッシュボードを立ち上げると
Atoms
Button
Default
Primary
Toggle
Link

が表示されます。

Interactions タブに移動すると
テストが PASS しています。

## カバレッジの計測

npm install -D @storybook/test-runner @storybook/addon-coverage

※カバレッジインストール後、storybook を再起動させておかないとエラーになります。

scripts を追加します。

```package.json
{
 "scripts": {
 ...
 "test-storybook": "test-storybook --coverage",
 }
}

```

```.storybook/main.ts

const config: StorybookConfig = {
 addons: [
 ...
 '@storybook/addon-coverage',
 ],
};

```

カバレッジの計測には storybook を起動させておく必要があります。
npm run storybook

カバレッジの計測(新しいターミナルで実行します。)
npm run test-storybook

インタラクションテストの動作確認
カバレッジの計測を確認

---

# Supabase

この Supabase 項目は

Supabase ローカル開発環境 ＋ サーバー運用を想定 2023 - Qiita

https://qiita.com/masakinihirota/items/be94b4c74a7850a4b79c

を参考にしてください。

ローカルに Supabase の CLI (command line interface)をインストールします。

scoop bucket add supabase https://github.com/supabase/scoop-bucket.git
scoop install supabase

アップデート
scoop update supabase

Supabase CLI のバージョン
supabase --version

Supabase 本体とクライアントと Supabase Auth ヘルパーのインストール
npm install supabase @supabase/supabase-js @supabase/auth-helpers-nextjs

Supabase の初期化
supabase init

## サーバー側との接続（必要な場合）

Supabase へのログイン
supabase login

Supabase プロジェクトへのリンク
supabase link

## Docker のインストール

Supabase ローカル開発環境 ＋ サーバー運用を想定 2023 - Qiita

https://qiita.com/masakinihirota/items/be94b4c74a7850a4b79c

を参考にしてください。

## ローカルの Supabase を始める

supabase start

```
06-18 15:49:49> supabase start
Seeding data supabase\seed.sql...me...
                                 Started supabase local development setup.

         API URL: http://localhost:54321
     GraphQL URL: http://localhost:54321/graphql/v1
          DB URL: postgresql://postgres:postgres@localhost:54322/postgres
      Studio URL: http://localhost:54323
    Inbucket URL: http://localhost:54324
      JWT secret: super-secret-jwt-token-with-at-least-32-characters-long
        anon key: eyJhb**********************************n_I0
service_role key: eyJhbGci*******************************pN81IU

```

ステータス
supabase status

ローカルの Supabase(Docker)を止める
supabase stop

## Supabase を利用したローカルでの開発

Supabase ローカル開発環境 ＋ サーバー運用を想定 2023 - Qiita

https://qiita.com/masakinihirota/items/be94b4c74a7850a4b79c

を参考にしてください。

## Supabase クライアントの基礎

src\utils\supabase.ts という新しいファイルを作成し、以下の内容を追加します。

```src\utils\supabase.ts

import { createClient } from '@supabase/supabase-js'

export default createClient(
 process.env.NEXT_PUBLIC_SUPABASE_URL!,
 process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
)

```

これを呼び出すことで Supabase クライアントが作成できます。

---

# サービスとの連携コマンド

プロジェクトを GitHub で公開して、それを Vercel から連携させます。

取得した独自ドメインがあるのならドメイン登録もできます。

vercel 関連
Next.js×Supabase×Vercel 連携について - Qiita

https://qiita.com/kaho_eng/items/8a7faf77222a599fb31c

npm vercel login

Vercel プロジェクトをローカル環境にクローンしたプロジェクトにリンクします。
npm vercel link

環境変数を連携した Vercel プロジェクトからコピーして .env.local に上書きできます。
npm vercel env pull

---


# i18n

[WIP]

---

# 削除してもいいフォルダ

src\stories

このフォルダは Storybook をインストールするときにデフォルトで入ってくるサンプルなのでサンプルを見ながら書く人以外は消してしまってもいいです。

※コロケーションパターンで開発するので、コンポーネントファイル、テストファイル、Story ファイルはすべて同一のフォルダに入れます。
理由は半年前も経てばどのファイルがどのフォルダに入っているかわからなくなるからです。なのでコロケーションパターンの原則を出来る限り守ります。
グローバル化したいものや共通化したいものは除く。

---

# 参考 URL

GitHub Qiita 記事
Supabase ローカル開発環境 ＋ サーバー運用を想定 2023

https://qiita.com/masakinihirota/items/be94b4c74a7850a4b79c

GitHub masakinihirota/vns
https://github.com/masakinihirota/vns

Supabase VNS

https://app.supabase.com/project/gzctqdrrnnkaxwwtzbsw

Vercel VNS

https://vercel.com/masakinihirota/vns

Next.js by Vercel - The React Framework

https://nextjs.org/

Storybook

https://storybook.js.org/docs/react/get-started/install/

React×TypeScript ではじめる Vitest

https://zenn.dev/bs_kansai/articles/b79d97a8f921d6

Storybook(v7)を Vitest で再利用するとき

https://zenn.dev/pluto0004/articles/3bab7d07805cff

Storybook の「インタラクションテスト」でフロントエンドのテストをシンプルに管理する！｜ SHIFT Group 技術ブログ

https://note.com/shift_tech/n/n5646b52b3092

[2023 年]Next.js + eslint 周りの設定

https://zenn.dev/resistance_gowy/articles/91b4f62b9f48ec

【環境構築】Next × App Router × Prettier × ESLint × Husky × Shadcn/ui の環境構築をしてみる - Qiita

https://qiita.com/hiroto_dnpk/items/a7ebbca3294c7befb4b7

---

# 未インストール

<details><summary>未インストール[WIP]</summary>

# vitest

テストツール

???
npm create vite@latest

React と TypeScript を選択します。

cd vitest-react
npm install
npm run dev

ここからインストール？
npm install -D vitest

npm install -D jsdom @testing-library/react @testing-library/jest-dom

.eslintignore
ファイル内に vitest.config.ts を書く

```
vite.config.ts
vitest.config.ts
.eslintrc.cjs

```

Vitest の設定
vite.config.ts

```vitest.config.ts
import { defineConfig } from 'vite'

export default defineConfig({
    test: {
        include: ['src/**/*.test.tsx'],
        environment: 'jsdom',
    },
})

```

src/以下のみに設定してある

## テストコードの作成

App コンポーネントに対して、「Vite + React」が表示されているかのテストを書いてみます。

```
import '@testing-library/jest-dom';
import { render, screen } from '@testing-library/react';
import { expect, test } from 'vitest';
import App from '../App';

test('renders h1 text', () => {
    render(<App />);
    const headerElement = screen.getByText("Vite + React");
    expect(headerElement).toBeInTheDocument();
});

```

実行
npm vitest

カバレッジの実行
npm vitest run --coverage

```
import { defineConfig } from 'vite'

export default defineConfig({
    test: {
        globals: true,
        include: ['src/**/*.test.tsx'],
        environment: 'jsdom',
        coverage: {
            reporter: ['html'],
            reportsDirectory: './coverage'
        },
    },
})

```

</details>

































































●●●●●●●●●●●●●●●●●●●●●●●
●●●●●●●●●●●●●●●●●●●●●●●





●●●●●●●●●●●●●●●●●●●●●●●
●●●●●●●●●●●●●●●●●●●●●●●





●●●●●●●●●●●●●●●●●●●●●●●
●●●●●●●●●●●●●●●●●●●●●●●








## 以前のテンプレート

Next.js app router 開発用テンプレート (Storybook Supabase shadcn/ui) - Qiita

https://qiita.com/masakinihirota/items/3ad7a1564d2b6c56d4db

Next.js App Router 開発用テンプレートに shadcn/ui でダークモードを実装する。 - Qiita

https://qiita.com/masakinihirota/items/7cf6181ba61fe9dc3802

※理由として、公式がApp Dir対応の認証付きサンプルを公開したためです。
この以前のテンプレート↑には認証は未実装でした。
app routerに対応した認証方法を各ユーザーが試行錯誤していた時期でした。
私自身も独自の認証よりは公式が採用している認証方式を採用して信頼度をあげたかったためそのまま採用しました。


# 邪魔する拡張機能

DeepL
この拡張機能はコンソールログに余分なエラーを吐く





#########################

# GitHub認証

最初のサンプルにはメール認証がついていましたが、
これにGitHub認証を追加してマルチ認証を実装します。



## 参考


4 Create an OAuth App with GitHub | egghead.io

https://egghead.io/lessons/supabase-create-an-oauth-app-with-github

Supabase GitHubでログイン - Oauth認証 - Qiita

https://qiita.com/maaaashi/items/05b4226f228a31088550

Next.jsでsupabaseを使って、認証からデータベースの更新までをやってみる

https://zenn.dev/hrtk/articles/3da84e46c97267



## SupabaseとGitHubの設定

まずは
Supabaseの左サイドバーのAuthenticationを選択します。
左サイドバーすぐ右側に Authenticationのリストが表示されます。
その中の Providers を選択すると、Auth Providers のリストが表示されます。

デフォルトでは Emailが Enable（有効化）されています。

GitHubを開き、
GitHubを選択して、
GitHub enabled ボタンを押します。

まず 一番下の Callback URL (for OAuth) がありますのでメモしておきます。

この Callback URL (for OAuth) は GitHubで使います。


次に
Client ID
Client Secret
この2つは GitHub の

Developer applications

https://github.com/settings/developers

このページから 右上にある New OAuth App ボタンを押して
これから作成するアプリを登録することで表示されます。



```
Register a new OAuth application
Application name
[アプリ名]

Homepage URL
[http://localhost:3000/]

Application description

Authorization callback URL
[Supabaseのダッシュボードから↓]
[https://jd***********wg.supabase.co/auth/v1/callback]

```

登録が完了したら

GitHubで
Client ID
Client Secret
をメモしておきます。

※Client Secret が表示されるのは一度だけですので取り扱いに気をつけてください。


Supabaseに戻ります。

Supabase の GitHubのところに戻ったら

Client ID
Client Secret
を登録して Save ボタンを押します。

これで Supabase と GitHub 相互に情報の登録が終わりました。

次にログインボタンを実装します。



# GitHub ログイン ボタンの実装







↓この動画を参考にします。


5 Authenticate Users with GitHub OAuth using Supabase and Next.js Client Components | egghead.io
https://egghead.io/lessons/supabase-authenticate-users-with-github-oauth-using-supabase-and-next-js-client-components


まずは
src\app\page.tsx
のページ表示部分をログイン以外削除します。


```src\app\page.tsx
import { createServerComponentClient } from "@supabase/auth-helpers-nextjs"
import { cookies } from "next/headers"
import Link from "next/link"
import LogoutButton from "../components/LogoutButton"

export default async function Index() {
  const supabase = createServerComponentClient({ cookies })

  const {
    data: { user },
  } = await supabase.auth.getUser()

  return (
    <div>
      {user ? (
        <div className="flex items-center gap-4">
          Hey, {user.email}!
          <LogoutButton />
        </div>
      ) : (
        <Link
          href="/login"
          className="px-4 py-2 no-underline rounded-md bg-btn-background hover:bg-btn-background-hover"
        >
          Login
        </Link>
      )}
    </div>
  )
}

```



touch src\app\auth-button.tsx

```src\app\auth-button.tsx
"use client";

import { createClientComponentClient } from "@supabase/auth-helpers-nextjs";

export default function AuthButton() {
  const supabase = createClientComponentClient();

  const handleSignOut = async () => {
    await supabase.auth.signOut();
  };

  const handleSignIn = async () => {
    await supabase.auth.signInWithOAuth({
      provider: "github",
      options: {
        redirectTo: "http://localhost:3000/auth/callback",
      },
    });
  };

  return (
    <>
      <button onClick={handleSignIn}>Login</button>
      <button onClick={handleSignOut}>Logout</button>
    </>
  );
}

```







































----------------------------------------
----------------------------------------







●●●●●●●●●●●●●●●●●●●●●●●
●●●●●●●●●●●●●●●●●●●●●●●





●●●●●●●●●●●●●●●●●●●●●●●
●●●●●●●●●●●●●●●●●●●●●●●





●●●●●●●●●●●●●●●●●●●●●●●
●●●●●●●●●●●●●●●●●●●●●●●





●●●●●●●●●●●●●●●●●●●●●●●
●●●●●●●●●●●●●●●●●●●●●●●





●●●●●●●●●●●●●●●●●●●●●●●
●●●●●●●●●●●●●●●●●●●●●●●





●●●●●●●●●●●●●●●●●●●●●●●
●●●●●●●●●●●●●●●●●●●●●●●





●●●●●●●●●●●●●●●●●●●●●●●
●●●●●●●●●●●●●●●●●●●●●●●





●●●●●●●●●●●●●●●●●●●●●●●
●●●●●●●●●●●●●●●●●●●●●●●





●●●●●●●●●●●●●●●●●●●●●●●
●●●●●●●●●●●●●●●●●●●●●●●





●●●●●●●●●●●●●●●●●●●●●●●
●●●●●●●●●●●●●●●●●●●●●●●





●●●●●●●●●●●●●●●●●●●●●●●
●●●●●●●●●●●●●●●●●●●●●●●





●●●●●●●●●●●●●●●●●●●●●●●
●●●●●●●●●●●●●●●●●●●●●●●





●●●●●●●●●●●●●●●●●●●●●●●
●●●●●●●●●●●●●●●●●●●●●●●





●●●●●●●●●●●●●●●●●●●●●●●
●●●●●●●●●●●●●●●●●●●●●●●





●●●●●●●●●●●●●●●●●●●●●●●
●●●●●●●●●●●●●●●●●●●●●●●





●●●●●●●●●●●●●●●●●●●●●●●
●●●●●●●●●●●●●●●●●●●●●●●





●●●●●●●●●●●●●●●●●●●●●●●
●●●●●●●●●●●●●●●●●●●●●●●





●●●●●●●●●●●●●●●●●●●●●●●
●●●●●●●●●●●●●●●●●●●●●●●





●●●●●●●●●●●●●●●●●●●●●●●
●●●●●●●●●●●●●●●●●●●●●●●





●●●●●●●●●●●●●●●●●●●●●●●
●●●●●●●●●●●●●●●●●●●●●●●





