<!--
title:   ９月末までに Supabase JWT Signing Keys (JWT署名鍵 非対称キー)に変更 公開鍵暗号方式
tags:    Supabase
id:      7d4f5d77b7aad60b7122
private: false
-->
９月末までに Supabase JWT Signing Keys (JWT署名鍵 非対称キー)に変更 公開鍵暗号方式

https://www.youtube.com/watch?v=hjgt_cgdkh0


👆️NotebookLMによるJWT署名鍵の解説動画 7分

## 何をするのか？

対称キー
から
非対称キーに変更します。

これまでサーバーに問い合わせていたものが、
非対称キーに変更することで、アプリ上から認証が可能になり、認証の時間も短縮されます。

JWT Signing Keys (JWT 署名鍵) は公開鍵暗号方式です。鍵(key)の名前も公開鍵暗号方式に沿って変更されています。

公開鍵と秘密鍵は別のものなので非対称キーと説明されています。
逆に同じ鍵(対称キー)、秘密鍵方式、共通鍵暗号方式などと呼ばれている方式です。

この秘密鍵方式は相手にも暗号鍵を渡す必要があるのでネットワーク上での利用はセキュリティリスクが高くなります。

たしか、2025年5月頃からアナウンスがあったと思います。



## Supabaseに適用するには、

既存のアプリでは
`getUser()` 部分を `getClaims()` に変えるだけで移行は完了です、ただしこのままでは性能は従来通りです。

それはサーバーに問い合わせているからです、非対称キーを利用すると、アプリ内で検証が可能となります。

本来のその性能を引き出すためには、非対称のJWTキーを生成して設定することで発揮する二段構えになっています。



----------------------------------------

## 用語

対称キー(同じ鍵、共通鍵など)

非対称キー(公開鍵、秘密鍵)

Current Key (現在使用中のキー)

Standby Key (準備中のキー)

anon key (匿名キー)

publishable key (公開鍵)

service_role Key (サービスの役割キー)

secret key (秘密鍵)

共通鍵暗号方式 ネット上で利用するとセキュリティリスクが高い

公開鍵暗号方式 ネット上で利用してもセキュリティリスクが低い

----------------------------------------

## 前提知識

Supabaseではキーの名前が変わります。(現在は過渡期で、期限は2025年9月末)

anon key (匿名キー)
から
publishable key (公開鍵)

service_role Key (サービスの役割キー)
から
secret key (秘密鍵)


と公開鍵暗号方式の従来の名前に沿った名前に変更されます。

つまり、JWT Signing Keys (JWT署名キー)は秘密鍵に相当します。

対称型のキーから非対称型のキーへ

秘密鍵暗号方式から公開鍵暗号方式へ
秘密鍵は1つだけで誰にも公開してはいけません、自分も相手も同じ鍵を使います、つまり対称の鍵です。
公開鍵暗号方式は公開鍵と秘密鍵を2つ作ります。相手は公開鍵を使い、自分は秘密鍵を使います、つまり非対称の鍵です。

## 公開鍵暗号方式の解説
公開鍵暗号方式は、秘密鍵暗号方式が抱える **「鍵配送問題」** を解決するために生まれました。秘密鍵暗号方式（対称型）では、通信する両者が同じ鍵を共有する必要があり、その鍵を安全に相手に渡すことが大きな課題でした。一方、公開鍵暗号方式（非対称型）では、公開鍵と秘密鍵のペアを用いることで、この問題を根本的に解決します。

## 公開鍵暗号方式への移行

非対称型キーは、公開鍵と秘密鍵という2つの異なる鍵を使用します。

公開鍵: 誰にでも公開できる鍵で、データの暗号化や署名の検証に使われます。
秘密鍵: 鍵の所有者だけが持つ鍵で、データの復号や署名に使われます。

アリスがボブにメッセージを送る場合、アリスはボブの公開鍵を使ってメッセージを暗号化します。この暗号化されたメッセージは、ボブが持つ秘密鍵でしか復号できません。これにより、鍵を事前に安全に共有する必要がなくなります。

Supabaseのキー名称変更は、この公開鍵暗号方式の考え方に沿ったものです。
anon key（匿名キー）は、ユーザー認証などのためにクライアントサイドで公開されるため、publishable key（公開キー）というより適切な名前に変更されました。
一方、サーバーサイドでの認証や署名に使われるJWT Signing Keysは、決して公開してはならないため、秘密鍵に相当します。



---

👇️ローカルのデータを確認

```terminal
supabase status

Stopped services: [supabase_imgproxy_vns-masakinihirota supabase_edge_runtime_vns-masakinihirota supabase_analytics_vns-masakinihirota supabase_vector_vns-masakinihirota]
supabase local development setup is running.

         API URL: http://127.0.0.1:54321
     GraphQL URL: http://127.0.0.1:54321/graphql/v1
  S3 Storage URL: http://127.0.0.1:54321/storage/v1/s3
          DB URL: postgresql://postgres:postgres@127.0.0.1:54322/postgres
      Studio URL: http://127.0.0.1:54323
    Inbucket URL: http://127.0.0.1:54324
      JWT secret: super-secret-jwt-token-with-at-least-32-characters-long  ＜＜ココ
        anon key: eyJh*****
service_role key: eyJh*****
   S3 Access Key: 6257*****
   S3 Secret Key: 8501*****
       S3 Region: local

```

👆️JWT secretの値は
JWT secret: super-secret-jwt-token-with-at-least-32-characters-long
となっています。
このままでは使えません、JWT secretの値は自分で作成します。

※これは公開鍵方式の秘密鍵にあたるので、使用するのでしたら公開してはいけません。



----------------------------------------

# 公式紹介動画1 2分

Supabaseで認証キーを使用する新しい方法
https://www.youtube.com/watch?v=htzj9SkkhhA

## ２つの新しい機能の追加

1. 公開鍵と秘密鍵
2. JWT Signing Keys (JWT署名鍵)

## 利用目的

ユーザーがサインインしているかのチェック

アプリケーションに追加ロジックは必要ない



----------------------------------------

## 公式紹介動画2 15分

Supabase Auth が大幅に高速化されました!
https://www.youtube.com/watch?v=rwnOal_xRtM

※日本語音声で詳しく解説されています。
この動画を見たほうが理解が早いと思います。



## 1:12 変更する時、最初にやること

getUserをgetClaimsに変更します。

claimsオブジェクトを返します。

例
!data?.claims

この様に変更しても同じように動作します。

symmetric
対称JWT
これは、Supabaseまたはサーバーによって検証される必要があります。

Asymmetric
非対称JWT
これは、
Supabaseまたはサーバーによって検証されます。
アプリケーションでも検証できます。

つまり、getUserの機能を受け継ぎつつ、アプリケーションでも検証できる新しい機能が追加されています。

getClaimsはどちらも実行できます。
非対称キーの場合ユーザーをローカルで検証しようとします。
対称キーの場合ユーザーをサーバーで検証しようとします。



### 動画5:30当たり

ヨーロッパ、オーストラリア 300 ms



### 動画6:20当たり

JWT署名キーの実装



### 7:36当たり 非対称キーに変更するには？

![ローテーション共通鍵から秘密鍵1.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/44761/c01b6182-1e09-4617-8b67-ced4aad02d88.png)


![ローテーション共通鍵から秘密鍵0.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/44761/7cccb501-a70a-4b97-a82e-4b18ff190926.png)


現在使用中のキーを、新しく生成したキーに変更します。
これをローテーションと呼んでいます。

つまりこれは、対称キー(同じ鍵)を非対称キー(公開鍵、秘密鍵)に変える仕組みです。
また、
非対称キーを新しい非対称キーに変える役割もあるようです。
鍵使用の一定期間後や漏洩が疑われた場合などに使われると思います。



APIキー
	* anon key
	* service_role key
は以前の古いJWTで署名したキーとなります。

### 8:43当たり 公開可能キーへの置き換え

NEXT_PUBLIC_SUPABASE_ANON_KEY
を
NEXT_PUBLIC_SUPABASE_PUBLISHABLE_OR_ANON_KEY
になります。

値は秘密キーに置き換えます。


キーの変更が正しく成功すると
認証の速度が2～3msと短くなります。



### 13:04当たり 実際に試す

👇インストールをします。

```terminal
npx create-next-app@latest -e with-supabase [アプリ名]

```

`.env.example` ファイルにサンプルがあります。


![ローテーション共通鍵から秘密鍵2.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/44761/f52c6972-b7e1-462a-ba83-e99d95bdf02c.png)

![ローテーション共通鍵から秘密鍵4.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/44761/f9e94874-a678-4f22-867e-0601a9187cd9.png)



サーバー側のSupabaseの場合

```.env.example
# Update these with your Supabase details from your project settings > API
# https://app.supabase.com/project/_/settings/api
NEXT_PUBLIC_SUPABASE_URL=your-project-url
NEXT_PUBLIC_SUPABASE_PUBLISHABLE_OR_ANON_KEY=your-anon-key

```

👆これ(.env.example)を👇このように(.env.local)置き換えます。

```.env.local
NEXT_PUBLIC_SUPABASE_URL=https://puqapokjzmloymkjvvoi.supabase.co
NEXT_PUBLIC_SUPABASE_PUBLISHABLE_DEFAULT_KEY=sb_publishable_ptU*****

```

それではログインしてみましょう、きちんとログインできて動いているなら正しく動いています。

※細かい所は動画をご覧くだい。



----------------------------------------

## ローカルでの署名鍵の生成

Supabase CLIがインストール済みであること

### supabase gen signing-key -h

コマンドで生成できます。

```terminal
supabase gen signing-key -h

Securely generate a private JWT signing key for use in the CLI or to import in the dashboard.

Supported algorithms:
        ES256 - ECDSA with P-256 curve and SHA-256 (recommended)
        RS256 - RSA with SHA-256

Usage:
  supabase gen signing-key [flags]

Flags:
      --algorithm [ RS256 | ES256 ]   Algorithm for signing key generation. (default ES256)
      --append                        Append new key to existing keys file instead of overwriting.
  -h, --help                          help for signing-key

Global Flags:
      --create-ticket                                  create a support ticket for any CLI error
      --debug                                          output debug logs to stderr
      --dns-resolver [ native | https ]                lookup domain names using the specified resolver (default native)
      --experimental                                   enable experimental features
      --network-id string                              use the specified docker network instead of a generated one
  -o, --output [ env | pretty | json | toml | yaml ]   output format of status variables (default pretty)
      --profile string                                 use a specific profile for connecting to Supabase API (default "supabase")
      --workdir string                                 path to a Supabase project directory
      --yes                                            answer yes to all prompts



```



### 鍵のアルゴリズム

• NIST P-256曲線 (非対称) ES256: 楕円曲線はRSAよりも高速で、同等のセキュリティを提供します。署名が短いため、データ転送サイズやクッキーサイズの管理に役立ちます。

• RSA 2048 (非対称) RS256: 最も古く広くサポートされている公開鍵暗号方式ですが、特定の側面で楕円曲線よりも大幅に遅くなる場合があります。



## 非対称鍵の生成

```terminal
supabase gen signing-key

To enable JWT signing keys in your local project:
1. Save the generated key to supabase\signing_key.json
2. Update your supabase\config.toml with the new keys path

[auth]
signing_keys_path = "./signing_key.json"



```



### 鍵の保存

生成した鍵を、`signing_key.json`ファイルを作って保存します。

supabaseフォルダと同じ場所に置きます。

```tree
supabase
    ├── .branches
    ├── .temp
    ├── migrations
    │   └── 20250908144020_remote_schema.sql
    ├── schemas
    ├── config.toml
    ├── seed.sql
    └── signing_key.json  ＜＜ココ

```


👇️`signing_key.json`ファイルを、Supabase設定ファイル(config.toml)に追加します。
[auth]項を探してそこに追加してください。

```config.tom
...
[auth]
signing_keys_path = "./signing_key.json"

```

※ここで場所やファイル名を自由に指定できます。

Supabaseクライアント (これはSupabaseにアクセスするためのクライアントのことを指しています。)

今までは対称型のキーを使っていましたが
これからは非対称のJWTキーを使うようになります。
この非対称のJWTキーを使うことによりローカル内で認証を確認できるようになり、ネットワークコストを抑えることが出来ます。



----------------------------------------

### **JWT署名キーについて**

SupabaseプロジェクトでJSON Web Tokens (JWT) に署名するために使用されるキーを管理するセクションです。JWTは、ユーザー認証のために情報を安全にやり取りするためのもので、署名キーはトークンの完全性と信頼性を保証する上で非常に重要です。

#### **キーの状態**

ダッシュボードには、主に2つのキーの状態が表示されています。

* **Current Key (現在のキー)**: **新しいJWTに署名するために現在使用されているキー**です。Supabase Authによって新しく発行されるトークンはすべて、このキーで署名されます。スクリーンショットでは、IDが`bb86d0f1-...`で始まり、タイプが**Legacy HS256 (Shared Secret)**になっています。

* **Standby Key (スタンバイキー)**: **使用準備が整っているキー**です。「**Rotate keys (キーをローテーション)**」ボタンをクリックすると、このキーが**新しいCurrent Key**になります。スクリーンショットでは、IDが`8ceedeef-...`で始まり、タイプは**ECC (P-256)**です。

#### **キーのローテーション**

「**Rotate keys**」ボタンは、定期的に署名キーを変更するためのセキュリティ機能です。これにより、キーが漏洩するリスクを軽減できます。このローテーションを行うと、以下のようになります。

1.  **Standby Key**が、新しい**Current Key**に昇格します。
2.  以前の**Current Key**は、「**Previously used keys (以前に使用されたキー)**」のリストに移動します。

この仕組みにより、古い有効なトークンは有効期限が切れるまで引き続き古いキーで検証でき、新しいトークンはすべて新しいキーで署名されるようになります。

スクリーンショットには「**No previously used keys (以前に使用されたキーはありません)**」と表示されているため、まだ一度もローテーションが行われていないことがわかります。

---

| ステータス | ID | タイプ | 役割 |
| :--- | :--- | :--- | :--- |
| **CURRENT KEY** | `bb86d0f1-*****` | `Legacy HS256` | 新しいトークンに署名する |
| **STANDBY KEY** | `8ceedeef-*****` | `ECC (P-256)` | ローテーションを待機する |



----------------------------------------

## 認証と認可の新しい常識：Superbaseのキー管理で、より安全で効率的なアプリ開発を

※AI によるまとめ

皆さん、こんにちは！Next.jsとSupabaseを使った開発は、そのスピードとシンプルさで多くの開発者を魅了しています。しかし、アプリケーションが成長するにつれて、「ユーザーの認証」や「データへのアクセス権限」といったセキュリティの課題に直面することがあります。

今回は、Supabaseが新たに導入したキー管理の概念と、それを活用した安全なアプリケーション構築のベストプラクティスについて解説します。

### 認証と認可、それぞれの役割を理解する

まず、混同されやすい**認証（Authentication）**と**認可（Authorization）**の違いを明確にしておきましょう。

* **認証**: 「あなたは誰ですか？」を証明するプロセスです。例えば、ログイン時にユーザー名とパスワードを検証する行為がこれにあたります。
* **認可**: 「あなたは、何にアクセスする権限を持っていますか？」を決定するプロセスです。例えば、管理者だけが特定の設定を変更できる、自分の投稿だけを編集できる、といったルールがこれに該当します。

### 認証を高速化する「JWT署名キー」

Supabaseは、JWT（JSON Web Token）を使ってユーザー認証を管理しています。新たに導入された**JWT署名キー**は、この認証プロセスを劇的に高速化します。

従来の認証では、ユーザーのJWTが有効かどうかを確認するために、毎回Supabaseのサーバーに問い合わせる必要がありました。しかし、JWT署名キーを使えば、アプリケーション自身がローカルでJWTの真正性を検証できます。

これにより、ページを読み込むたびに認証チェックを行うNext.jsのミドルウェアなどで、ネットワーク遅延のない、**即座の認証**が可能になります。

### 認可を完璧にする「RLS」と「RBAC」

次に、認可をどう実装するかです。ここで鍵となるのが、**RLS（Row Level Security）**と**RBAC（Role-Based Access Control）**の考え方です。

* **RLS**は、データベースの**行（レコード）単位**でアクセス権限を制御するSupabaseの強力な機能です。
* **RBAC**は、ユーザーに**役割（ロール）**を割り当ててアクセス権を管理するセキュリティモデルです。

この二つを組み合わせることで、堅牢な認可システムを構築できます。例えば、「`admin`という役割を持つユーザーはすべてのデータにアクセスできる」「`editor`という役割を持つユーザーは、自分が所属するグループの投稿のみ編集できる」といった、複雑なルールをデータベースに直接設定できます。

ユーザーをグループ化したり、グループをさらに「アライアンス」としてまとめたりするような複雑な階層構造も、RLSを活用すれば完璧に対応できます。

### 新しいAPIキーの登場：公開キーと秘密キー

これまでの`anon`キーと`service_role`キーは、新しいAPIキーに置き換えられます。

* **公開可能キー（Publishable Key）**: 従来の`anon`キーに代わるものです。これは**クライアントサイド**での利用が安全ですが、データのセキュリティはRLSで確保する必要があります。
* **秘密キー（Secret Key）**: 従来の`service_role`キーに代わり、**サーバーサイド専用**のキーです。

この秘密キーの最大の進化点は、**複数のキーを生成できる**ようになったことです。これにより、モバイルアプリや特定の管理ツールなど、用途ごとにキーを分けることができます。万が一、一つのキーが漏洩しても、その影響範囲を最小限に抑えられ、**セキュリティが大幅に向上**します。

### まとめ

* **認証**は**JWT署名キー**で高速化。
* **認可**は**RLS**と**RBAC**の組み合わせで堅牢化。
* 新しい**公開キー**と**秘密キー**で、セキュリティと管理の柔軟性が向上。

これらの新しい概念を理解し活用することで、皆さんのアプリケーションはより安全で、よりパフォーマンスの高いものになります。ぜひ、ご自身のプロジェクトで試してみてください！


----------------------------------------

## AI(NotebookLM)による内容のチェックしてレビュー

提供された記事内容をレビューします。

この記事は、SupabaseがJWT (JSON Web Token) の署名鍵を**対称キー方式から非対称キー方式（公開鍵暗号方式）へ変更する**ことについて、その詳細、背景、メリット、移行方法、および関連するセキュリティ概念について解説しています。

---

### **1. 変更の概要と目的**

*   **移行期限**: 2025年9月末までに、既存のJWT署名鍵が**対称キーから非対称キーへ変更**されます。
*   **主な目的とメリット**:
    *   **認証時間の短縮**: これまではサーバーに問い合わせていた認証が、非対称キーに変更することで**アプリ内での検証が可能**になり、認証時間が短縮されます（2～3msまで短縮されるとされています）。これにより、Next.jsのミドルウェアなど、ページ読み込みごとに認証を行う際の効率が大幅に向上します。
    *   **セキュリティの向上**: 公開鍵暗号方式は、鍵配送問題を解決し、ネットワーク上での利用時のセキュリティリスクが低いとされています。また、新しい秘密キーでは**複数のキーを生成できる**ようになり、キー漏洩時の影響範囲を最小限に抑え、セキュリティが大幅に向上します。

---

### **2. 対称キーと非対称キーの比較**

*   **対称キー（共通鍵暗号方式）**:
    *   同じ鍵を送信者と受信者が共有し、暗号化と復号化の両方に使用します。
    *   相手にも暗号鍵を渡す必要があるため、ネットワーク上での利用は**セキュリティリスクが高い**と説明されています。
    *   Supabaseまたはサーバーによって検証されます。
*   **非対称キー（公開鍵暗号方式）**:
    *   **公開鍵**と**秘密鍵**のペアを使用します。
    *   **公開鍵**は誰にでも公開でき、データの暗号化や署名の検証に使われます。
    *   **秘密鍵**は鍵の所有者のみが持ち、データの復号や署名に使われます。
    *   「鍵配送問題」を解決するために生まれ、ネットワーク上で利用してもセキュリティリスクが低いとされています。
    *   Supabaseまたはサーバーによって検証されるだけでなく、**アプリケーションでも検証可能**です。

---

### **3. Supabaseキー名称の変更**

Supabaseのキー名称は、公開鍵暗号方式の考え方に沿って変更されます。

*   `anon key` (匿名キー) → **`publishable key` (公開可能キー)**
    *   クライアントサイドでの利用が安全ですが、データのセキュリティはRLSで確保する必要があります。
*   `service_role Key` (サービスの役割キー) → **`secret key` (秘密キー)**
    *   サーバーサイド専用のキーで、JWT Signing Keysはこれに相当します。

---

### **4. 認証（Authentication）と認可（Authorization）**

記事では、認証と認可の役割を明確に区別しています。

*   **認証 (Authentication)**:
    *   「あなたは誰ですか？」を証明するプロセスです（例: ログイン時のユーザー名とパスワードの検証）。
    *   JWT署名キーはこの認証プロセスを**劇的に高速化**します。
*   **認可 (Authorization)**:
    *   「あなたは、何にアクセスする権限を持っていますか？」を決定するプロセスです。
    *   JWT署名キーは認証効率化に役立ちますが、特定のデータへのアクセス権限を制御する**認可ロジックには直接関係しません**。
    *   **RLS (Row Level Security)**: データベースの**行（レコード）単位**でアクセス権限を制御するSupabaseの強力な機能です。
    *   **RBAC (Role-Based Access Control)**: ユーザーに**役割（ロール）**を割り当ててアクセス権を管理するセキュリティモデルです。
    *   これら二つを組み合わせることで、堅牢な認可システムを構築できます。

---

### **5. 移行方法と設定**

1.  **既存アプリの変更**:
    *   `getUser()`関数を**`getClaims()`**に変更することで移行は完了しますが、これだけでは性能は従来通りです。
    *   `getClaims()`は`claims`オブジェクトを返し、対称キーと非対称キーの両方に対応し、非対称キーの場合はローカルでユーザーを検証します。
2.  **非対称JWTキーの生成と設定**:
    *   Supabase CLIがインストールされていることを確認。
    *   `supabase gen signing-key`コマンドで非対称キーを生成します。
        *   推奨アルゴリズムは**ES256**（楕円曲線暗号、高速で同等セキュリティを提供）。
        *   他にRS256（RSA、広くサポートされているが遅い場合がある）があります。
    *   生成された鍵を`supabase\signing_key.json`のようなファイルに保存。
    *   `supabase\config.toml`の`[auth]`セクションに`signing_keys_path = "./signing_key.json"`を追加して、鍵のパスを設定します。
3.  **環境変数の変更**:
    *   `NEXT_PUBLIC_SUPABASE_ANON_KEY`を**`NEXT_PUBLIC_SUPABASE_PUBLISHABLE_OR_ANON_KEY`**に置き換えます。値は秘密キーに置き換えます。

---

### **6. キーのローテーション**

Supabaseは、セキュリティ機能としてJWT署名キーの**ローテーション**（定期的な変更）をサポートしています。

*   **Current Key**: 現在、新しいJWTに署名するために使用されているキー。
*   **Standby Key**: 次のCurrent Keyとして使用準備が整っているキー。
*   「**Rotate keys (キーをローテーション)**」ボタンをクリックすると、Standby Keyが新しいCurrent Keyに昇格し、以前のCurrent Keyは「Previously used keys (以前に使用されたキー)」のリストに移動します。
*   これにより、古い有効なトークンは有効期限が切れるまで引き続き古いキーで検証でき、新しいトークンはすべて新しいキーで署名されるようになります。

---

### **7. その他**

*   Supabaseクライアントは、これまでの対称型キーから非対称のJWTキーを使うようになり、ローカル内での認証確認によりネットワークコストを抑えることが可能になります。
*   記事には、具体的な実装例としてNext.jsとSupabaseを組み合わせたアプリケーションのセットアップコマンドや環境変数の設定例も含まれています。
*   公式のブログ記事、ドキュメント、および詳細な解説動画へのリンクも提供されており、さらに深い理解を助けます。
*   ローカル開発環境でのJWT署名鍵に関する既知の問題も言及されています。

---

**まとめると**、この資料はSupabaseユーザーに対し、JWT署名鍵の非対称キーへの移行が、**認証の劇的な高速化とアプリケーションのセキュリティ強化**をもたらす重要な変更であることを伝えています。具体的な移行手順、新しいキーの管理方法、および認証と認可の概念の違いを理解することの重要性が強調されています。




----------------------------------------

## その他

署名キーは認証（Authentication）の効率化に役立ちますが、認可（Authorization）のロジック、特に特定のデータへのアクセス権限を制御する目的には直接関係ありません。

その場合はRLSを利用します。



----------------------------------------

## 参考

### JWT Signing Keys の紹介(公式Blog)

Introducing JWT Signing Keys
https://supabase.com/blog/jwt-signing-keys

### Signing Keys ドキュメント

JWT Signing Keys | Supabase Docs
https://supabase.com/docs/guides/auth/signing-keys

### JWT とは

JSON Web Token (JWT) | Supabase Docs
https://supabase.com/docs/guides/auth/jwts#verifying-a-jwt-from-supabase

### Supabaseで認証キーを使用する新しい方法 2分

Supabaseで認証キーを使用する新しい方法
https://www.youtube.com/watch?v=htzj9SkkhhA

Next.js の Middlewareなどページ読み込みごとに認証を行う場合、認証の効率を大幅に向上させます。


### 公式による具体的な実装動画 15分

Supabase Auth が大幅に高速化されました!
https://www.youtube.com/watch?v=rwnOal_xRtM



## 既知の問題

JWT signing keys in local development yields client failure · Issue #4098 · supabase/cli
https://github.com/supabase/cli/issues/4098