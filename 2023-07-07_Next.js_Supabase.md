<!--
title:   Next.js app router 開発用テンプレート (Storybook Supabase shadcn/ui)
tags:    Next.js,Supabase,storybook,shadcn/ui
id:      3ad7a1564d2b6c56d4db
private: false
-->

# 開発用テンプレート
Next.jsと関連するツールをインストールしてNext.jsアプリ開発のテンプレートとして利用します。

本体コードはゼロ

# 開発中の確認＆ダッシュボード

Next.js
http://localhost:3000

Storybook
http://localhost:6006/

ローカルのSupabase
http://localhost:54323/projects

サーバーのSupabase
https://app.supabase.com/projects

GitHub
masakinihirota/next13apptemplate
https://github.com/masakinihirota/next13apptemplate

Vercel
https://vercel.com/dashboard

----------------------------------------

# 便利サイト、チートシート

Tailwind CSS Cheat Sheet

https://tailwindcomponents.com/cheatsheet/



----------------------------------------

# 重要コマンド
よく使うコマンドや便利ツール等

```
Supabase CLI 更新
scoop update supabase

Next.jsローカルサーバーを起動
npm run dev

storybookを起動
npm run storybook

supabase start
supabase stop
supabase db reset
supabase status

Supabase ダッシュボード
http://localhost:54323

ストーリーブック
npm run storybook

インタラクションテスト (storybookを起動させて)
npm run test-storybook

Vercel
npx vercel login
npx vercel link
npx vercel env pull

インストール時から一定期間後に別ブランチを立てて実行
update可能なパッケージ一覧を取得
npm outdated

npm update

インストール
npm install -g npm-check-updates
npm-check-updates

ncu

全て最新バージョンにアップデートしたい場合は
ncu -u




開発ブランチのマージ

git checkout main
git merge -
※ - 記号は直前にチェックアウトしたブランチを指定してマージします。



```

# 作業コマンド

短縮コマンド
cb	ブランチの作成

mainブランチに移動
main

ブランチのマージ
直前にいたブランチのマージ
git merge -

ブランチの削除
DDD ブランチ名

git merge [マージしたいブランチ名]



----------------------------------------

Next.js 13 app router テンプレートの作成

# リポジトリ名

next13apptemplate



# 環境

Next.js をインストール

<details><summary>インストールするその他のツール(長い)</summary>

(未)＝未インストール＆インストール候補

※ 重要なのは必要になった時に調べてインストールする。
一気に全部入れても混乱するだけで使いこなせません。

Next.js by Vercel - The React Framework

https://nextjs.org/

TypeScript: JavaScript With Syntax For Types.

https://www.typescriptlang.org/

Tailwind CSS - Rapidly build modern websites without ever leaving your HTML.

https://tailwindcss.com/

Find and fix problems in your JavaScript code - ESLint - Pluggable JavaScript Linter

https://eslint.org/

Prettier · Opinionated Code Formatter

https://prettier.io/

The Open Source Firebase Alternative | Supabase

https://supabase.com/

Storybook: Frontend workshop for UI development

https://storybook.js.org/

GitHub Japan | GitHub

https://github.co.jp/

Vercel

https://vercel.com/

(未) tRPC - Move Fast and Break Nothing. End-to-end typesafe APIs made easy. | tRPC

https://trpc.io/



## テスト関連

(未) Vitest | A blazing fast unit test framework powered by Vite

https://vitest.dev/

サンプル
next.js/examples/with-vitest at canary · vercel/next.js · GitHub

https://github.com/vercel/next.js/tree/canary/examples/with-vitest

(未) Chromatic: Storybook deployment, review, and test

https://www.chromatic.com/

(未) Testing Library | Testing Library

https://testing-library.com/

(未) JavaScript Component Testing and E2E Testing Framework | Cypress
https://www.cypress.io/

(未) Fast and reliable end-to-end testing for modern web apps | Playwright

https://playwright.dev/

(未) Jest · 🃏 Delightful JavaScript Testing

https://jestjs.io/ja/



## i18n 国際化

(未) react-i18next

Introduction - react-i18next documentation

https://react.i18next.com/

サンプル
next.js/examples/app-dir-i18n-routing at canary · vercel/next.js · GitHub

https://github.com/vercel/next.js/tree/canary/examples/app-dir-i18n-routing



# 他のインストール候補

## UI

Next.jsの app routerに対応している UI コンポーネント集

shadcn/ui

https://ui.shadcn.com/

Next.js - shadcn/ui

https://ui.shadcn.com/docs/installation/next

ReactのUIコンポーネントなら@shadcn/uiがちょうどいい

https://zenn.dev/mottox2/articles/react-shadcn-ui



(未) Kuma UI

https://www.kuma-ui.com/

(未) Mantine next example

https://v7.mantine.dev/

Can I use Mantine with Next.js app dir?
Currently, it is not recommended, we are working on new major version that will resolve all of the current issues related to server side rendering.

>MantineをNext.js app dirで使用できますか？
サーバーサイドレンダリングに関する現在の問題をすべて解決する新しいメジャーバージョンを開発中です。

このversion7が開発中です。



## デザイン

Figma

https://www.figma.com/



## 開発時の利用ツール

DB関連
SQLクライアント

DBeaver Community

https://dbeaver.io/download/

TablePlus | Modern, Native Tool for Database Management

https://tableplus.com/download

A5:SQL Mk-2 - フリーのSQLクライアント/ER図作成ソフト (松原正和)

https://a5m2.mmatsubara.com/



# その他

(未) Zod | Documentation

https://zod.dev/

(未) Prisma | Next-generation ORM for Node.js & TypeScript

https://www.prisma.io/



</details>



# ルール

書いたコードはsrcフォルダ以下に移動する
src/

共通のstyleコード
src/styles



ブランチは基本2種類
mainブランチ 公開用のコード
必要に応じて開発用のブランチを作成(ここで開発をする)
この２つを軸に開発していく
一区切りついたら開発用のブランチをmainにマージしていく



## 開発手法

コロケーション

コロケーションとは、
関連するコードを近くに配置することで、
コードの理解性を向上させる設計パターンの一つです。
コロケーションパターンともいいます。

コロケーションパターンを採用することで
リマインド効果がある
半年前の自分は別人理論
コードを読みやすくする

一つのフォルダの中に一つのコンポーネント単位を置く
コンポーネントは複数のコンポーネントで成り立っておい
一つはデータコンポーネント
一つは表示コンポーネント
をつかう
テストファイルと
Storyファイルも一緒に
コンポーネントフォルダのrootに置く

コロケーション | makotot.dev ファイルの配置
https://www.makotot.dev/posts/colocation-translation-ja

インタラクションテスト
ストーリーとテストを一元管理できる
ストーリーファイルにテストを記述する事になるため、
ストーリーとテストを一元管理できます。

テストを実行する方法は主に2つで、
通常はブラウザ上でStorybookを
表示して実行します。

テストランナーをセットアップすることで、
CLIでの実行が可能になります。



# ディレクトリ構成

```tree
src
├── app
│   ├── layout.tsx
│   └── page.tsx
├── components
│   ├── ui
│   │   ├── alert-dialog.tsx
│   │   ├── button.tsx
│   │   ├── dropdown-menu.tsx
│   │   └── ...
│   ├── main-nav.tsx
│   ├── page-header.tsx
│   └── ...
├── lib
│   └── utils.ts
├── styles
│   └── globals.css
├── next.config.js
├── package.json
├── postcss.config.js
├── tailwind.config.js
└── tsconfig.json



```

参考
Next.js - shadcn/ui
https://ui.shadcn.com/docs/installation/next



----------------------------------------

# インストール

npmを最新にする
npm install -g npm@latest

## Next.jsをインストール
npx create-next-app@latest

√ What is your project named? ... vns
√ Would you like to use TypeScript? ... No / Yes
√ Would you like to use ESLint? ... No / Yes
√ Would you like to use Tailwind CSS? ... No / Yes
√ Would you like to use `src/` directory? ... No / Yes
√ Would you like to use App Router? (recommended) ... No / Yes
√ Would you like to customize the default import alias? ... No / Yes
√ What import alias would you like configured? ... @/*



.eslintrc.json(初期)

```.eslintrc.json
{
  "extends": "next/core-web-vitals"
}

```



## TailwindCSS

https://nextjs.org/docs/app/building-your-application/styling/tailwind-css

src\app\globals.css
このファイルの配置を
src\styles\globals.css
へ移動します。

コマンド
New-Item -ItemType Directory -Path "src\styles"
Move-Item -Path "src\app\globals.css" -Destination "src\styles\globals.css"


globals.cssファイルから、デフォルトのインストール画面で必要だったCSS部分を削除し、TailwindCSSで必要な部分だけを残します。

```src\styles\globals.css
@tailwind base;
@tailwind components;
@tailwind utilities;

```



globals.cssファイルを読み込んでいるファイルのpathを修正します。

```src\app\layout.tsx
import '@/styles/globals.css'

...

<html lang='ja'>

```

日本語にも直しておきます。



## Storybookのインストール

npx storybook@latest init


TailwindCSSをStorybookでも適用されるように設定します。

```.storybook/preview.ts
import "../src/styles/globals.css"

```



----------------------------------------

## eslint


Next.jsとStorybookをインストールした直後のeslintの設定

```.eslintrc.json
{
  "extends": [
    "next/core-web-vitals",
    "plugin:storybook/recommended"
  ]
}

```

next.js/packages/eslint-config-next/index.js at canary · vercel/next.js · GitHub
https://github.com/vercel/next.js/blob/canary/packages/eslint-config-next/index.js

上記コードを調べるとnext/core-web-vitalsは
react/recommended
react-hooks/recommended
next/recommended
を読み込んでいるので、これらのインストールは不要です。



### .eslintignoreファイルの作成

touch .eslintignore

lintから外したいファイルを設定します。

```.eslintignore
# config
.eslintrc.js
prettier.config.js
next.config.js
tailwind.config.js
tsconfig.json
postcss.config.js

# build dir
build/
bin/
obj/
out/
.next/

# Storybook
*.stories.ts
*.stories.tsx

```.


# prettier

Install · Prettier
https://prettier.io/docs/en/install.html

npm install -D prettier eslint-config-prettier

.eslintrc.jsonにprettier設定の追加をします。

```.eslintrc.json
{
  "extends": [
    "next/core-web-vitals",
    "plugin:storybook/recommended",
    "prettier"
  ]
}

```



package.jsonにscriptを追加します。

```package.json

	"format": "prettier --write ."

```


## prettier.config.js 設定ファイルの追加 

touch prettier.config.js

```prettier.config.js
/** @type {import('prettier').Config} */
module.exports = {
    "semi": false,
    "singleQuote": false,
    "printWidth": 80,
    "tabWidth": 2,
    "trailingComma": "all",
    "jsxSingleQuote": true
  }

```



次に、.prettierignore ファイルを作成して、どのファイルをフォーマットしないかを Prettier CLI とエディターに知らせます。

touch .prettierignore

```.prettierignore
# Ignore artifacts:
build
coverage

# dotfile
.env*

# markdown
*.md

# next.js
/.next/
/out/

# production
/build

package-lock.json

```

動作確認のため
prettierを実行します。

npx prettier . --write

巨大プロジェクトの場合に時間短縮のため
フォルダを指定
prettier --write app/

ファイルを指定
prettier --write app/components/Button.js

globを使用してtestファイルだけ指定
prettier --write "app/**/*.test.js"

prettierが実行されているかの確認（上書きはしない）
npx prettier . --check





eslintで必要なプラグインを設定します。

javascriptのlint設定がないので
eslint:recommended
を入れます。


```.eslintrc.json
{
  "extends": [
    "eslint:recommended",
    "next/core-web-vitals",
    "plugin:storybook/recommended",
    "prettier"
  ]
}

```



npm i -D @typescript-eslint/parser 

npm i -D @typescript-eslint/eslint-plugin

```.eslintric.js
{
  "extends": [
    "eslint:recommended",
    "plugin:@typescript-eslint/recommended",
    "plugin:@typescript-eslint/recommended-requiring-type-checking",
    "next/core-web-vitals",
    "plugin:storybook/recommended",
    "prettier"
  ],
  "parser": "@typescript-eslint/parser",
  "parserOptions":  {
    "project": "./tsconfig.json"
  },
  "plugins": [
    "@typescript-eslint"
  ],
  "root": true
}

```


便利プラグインを追加します。
tailwindcssを並べ替えします。

prettier-plugin-tailwindcss


npm install -D prettier-plugin-tailwindcss

インストールしても自動化されない環境もあります。
その場合は設定に書き込みます。


```prettier.config.js
/** @type {import('prettier').Config} */
module.exports = {
    "plugins": [require('prettier-plugin-tailwindcss')],
    "semi": false,
    "singleQuote": true,
    "printWidth": 80,
    "tabWidth": 2,
    "trailingComma": "all",
    "jsxSingleQuote": true
  }

```



# eslint-plugin-import

import文の並べ替えを自動化します。

npm install eslint-plugin-import --save-dev



```.eslintrc.json
{
  "extends": [
    "eslint:recommended",
    "plugin:@typescript-eslint/recommended",
    "plugin:@typescript-eslint/recommended-requiring-type-checking",
    "next/core-web-vitals",
    "plugin:storybook/recommended",
    "prettier"
  ],
  "parser": "@typescript-eslint/parser",
  "parserOptions":  {
    "project": "./tsconfig.json"
  },
  "plugins": [
    "import",
    "@typescript-eslint"
  ],
  "root": true,
  "rules": {
    "import/order": [
      "error",
      {
        "groups": [
          "builtin",
          "external",
          "internal",
          ["parent", "sibling"],
          "object",
          "type",
          "index"
        ],
        "newlines-between": "always",
        "pathGroupsExcludedImportTypes": ["builtin"],
        "pathGroups": [
          {
            "pattern": "@/utils/**",
            "group": "internal",
            "position": "before"
          },
          {
            "pattern": "@/libs/**",
            "group": "internal",
            "position": "before"
          },
          {
            "pattern": "@/hooks/**",
            "group": "internal",
            "position": "before"
          },
          {
            "pattern": "@/components/**",
            "group": "internal",
            "position": "before"
          },
          {
            "pattern": "@/const/**",
            "group": "internal",
            "position": "before"
          },
          {
            "pattern": "@/types/**",
            "group": "internal",
            "position": "before"
          }
        ],
        "alphabetize": {
          "order": "asc"
        }
      }
    ]
  }
}

```





# コミット時にコードの検証と自動整形をします。

huskyを入れてcommit時にlint --fixが走るようにします。

npm install --save-dev husky lint-staged
npx husky install
npm pkg set scripts.prepare="husky install"
npx husky add .husky/pre-commit "npx lint-staged"

※このlint-stagedの設定ではnextjsでlintを実行するとエラーが起きてしまします。



touch .lintstagedrc.js


```.lintstagedrc.js
const path = require('path')

const buildEslintCommand = (filenames) =>
  `next lint --fix --file ${filenames
    .map((f) => path.relative(process.cwd(), f))
    .join(' --file ')}`

module.exports = {
  '*.{ts,tsx}': [
        () => 'tsc --incremental false --noEmit',
        buildEslintCommand,
        "prettier --write"
    ],
}

```


この設定をすると
{.ts,.tsx}ファイルに対してnext lintと prettier
をコミット時に行ってくれます。





huskyの確認

git config --local core.hooksPath
> .husky

git config --local core.hooksPath は、Gitのローカルリポジトリに対して、Gitフックスクリプトのパスを設定するコマンドです。

Gitフックスクリプトは、Gitの特定のイベントが発生したときに自動的に実行されるスクリプトです。例えば、コミットをする前にコードのフォーマットを自動的に修正するスクリプトを実行することができます。




----------------------------------------

# shadcn/ui

Next.js - shadcn/ui
https://ui.shadcn.com/docs/installation/next

ReactのUIコンポーネントなら@shadcn/uiがちょうどいい
https://zenn.dev/mottox2/articles/react-shadcn-ui

コンポーネントはCLIからインストールする方法と
サイトからコードをコピーするやり方があります。



shadcn/ui公式の推奨 Next.jsアプリの構成

```tree
src
├── app
│   ├── layout.tsx
│   └── page.tsx
├── components
│   ├── ui
│   │   ├── alert-dialog.tsx
│   │   ├── button.tsx
│   │   ├── dropdown-menu.tsx
│   │   └── ...
│   ├── main-nav.tsx
│   ├── page-header.tsx
│   └── ...
├── lib
│   └── utils.ts
├── styles
│   └── globals.css
├── next.config.js
├── package.json
├── postcss.config.js
├── tailwind.config.js
└── tsconfig.json

```



セットアップ 初期化

UIの保存フォルダを作っておきます
src/components/ui


npx shadcn-ui@latest init

```
> npx shadcn-ui@latest init
√ Would you like to use TypeScript (recommended)? ... no / yes
√ Which style would you like to use? » New York
√ Which color would you like to use as base color? » Slate
√ Where is your global CSS file? ... src/styles/globals.css
√ Would you like to use CSS variables for colors? ... no / yes
√ Where is your tailwind.config.js located? ... tailwind.config.js
√ Configure the import alias for components: ... @/components
√ Configure the import alias for utils: ... @/lib/utils
√ Are you using React Server Components? ... no / yes
√ Write configuration to components.json. Proceed? ... yes

✔ Writing components.json...
✔ Initializing project...
✔ Installing dependencies...

Success! Project initialization completed.

```


ヘルプコマンド
npx @shadcn/ui 

CLIからのインストール方法
npx @shadcn/ui add

インストールするコンポーネントを選択します。
Aですべてを選択します。
※すべて選択してインストールするとエラーになった

インストール先を指定します。
src/components/ui

※注意：すでに同じコンポーネント名が存在すると上書きされます。



## お試し

buttonコンポーネントをインストールしてみます。

npx @shadcn/ui add

buttonを選択します。

インストール先を指定します。



動作確認用

```src\app\page.tsx
import { Button } from '@/components/ui/button'

export default function Home() {
  return (
    <main>
      <Button>Button</Button>
    </main>
  )
}

```



----------------------------------------

# Storybookの動作確認

npm run storybook

Storybook
http://localhost:6006/

コロケーションパターンで開発するので、
コンポーネントファイルと
ストーリーファイル(SF3)と
テストファイルを同一フォルダ内に入れます。

現在はデフォルトのコンポーネントがstoriesフォルダに入っています。


## Storybookインタラクションテストの組み込み

Play function
https://storybook.js.org/docs/react/writing-stories/play-function


npm install @storybook/testing-library @storybook/jest @storybook/addon-interactions --save-dev

Storybookの「インタラクションテスト」でフロントエンドのテストをシンプルに管理する！｜SHIFT Group 技術ブログ
https://note.com/shift_tech/n/n5646b52b3092


インタラクションテストに対応した
コンポーネントと
ストーリーを作成します。



```Button.tsx
import React, { useState } from "react";
import { useRouter } from "next/router";
import "./button.css";

interface ButtonProps {
  testId: string;
  label: string;
  text?: string;
  href?: string;
  primary?: boolean;
  "data-testid"?: string;
}

export const Button = ({
  testId,
  label,
  text,
  href,
  primary = false,
  ...props
}: ButtonProps) => {
  const [textToggle, setTextToggle] = useState(false);
  const router = useRouter();
  const mode = primary ? "primary" : "";

  const onClick = () => {
    if (href) {
      router.push(href);
    } else {
      setTextToggle(!textToggle);
    }
  };

  return (
    <div>
      <button
        data-test-id={testId}
        type="button"
        className={["button", mode].join(" ")}
        onClick={onClick}
        {...props}
      >
        {　label　}
      </button>
      {textToggle && <div>{text}</div>}
    </div>
  );
};

```



```button.css
.button {
  font-family: "Nunito Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
  font-size: 20px;
  font-weight: 700;
  border: 0;
  border-radius: 3em;
  cursor: pointer;
  display: inline-block;
  line-height: 1;
  padding: 10px 20px;
  color: #333;
  background-color: transparent;
  box-shadow: rgba(0, 0, 0, 0.15) 0px 0px 0px 1px inset;
}
.primary {
  color: white;
  background-color: #1ea7fd;
}

```


```Button.stories.ts
import type { Meta, StoryObj } from "@storybook/react";
import { within, userEvent } from "@storybook/testing-library";
import { jest, expect } from "@storybook/jest";

import { Button } from "./Button";

const fn = jest.fn();

const meta: Meta<typeof Button> = {
  title: "Atoms/Button",
  component: Button,
  tags: ["autodocs"],
  parameters: {
    nextjs: {
      router: {
        push: fn,
      },
    },
  },
};

export default meta;
type Story = StoryObj<typeof Button>;

export const Default: Story = {
  args: {
    label: "Default",
    "data-testid": "button",
  },
  play: async ({ canvasElement, step }) => {
    const canvas = within(canvasElement);

    await step("ボタンにLabelの文字列が表示されている", async () => {
      await expect(canvas.getByText("Default")).toBeInTheDocument();
    });
  },
};

export const Primary: Story = {
  args: {
    primary: true,
    label: "Primary",
    "data-testid": "button",
  },
  play: async ({ canvasElement, step }) => {
    const canvas = within(canvasElement);

    await step("ボタンのclassName属性にprimaryが適用されている", async () => {
      const button = canvas.getByTestId("button");
      await expect(button.classList.contains("primary")).toBe(true);
    });
  },
};

export const Toggle: Story = {
  args: {
    label: "Toggle",
    text: "Success",
    "data-testid": "button",
  },
  play: async ({ canvasElement, step }) => {
    const canvas = within(canvasElement);

    await step("ボタン押下でtextを表示する", async () => {
      await userEvent.click(canvas.getByTestId("button"));
      await expect(canvas.getByText("Success")).toBeInTheDocument();
    });

    await step("再度ボタン押下でtextを非表示にする", async () => {
      await userEvent.click(canvas.getByTestId("button"));
      await expect(canvas.queryByText("Success")).toBeNull();
    });
  },
};

export const Link: Story = {
  args: {
    label: "Link",
    href: "/auth/login",
    "data-testid": "button",
  },
  play: async ({ canvasElement, step }) => {
    const canvas = within(canvasElement);

    await step("ボタン押下でhrefで指定した画面に遷移する", async () => {
      await userEvent.click(canvas.getByTestId("button"));
      await expect(fn.mock.lastCall).toContainEqual("/auth/login");
    });
  },
};

```

Storybookのダッシュボードを立ち上げると
Atoms
	Button
		Default
		Primary
		Toggle
		Link

が表示されます。

Interactionsタブに移動すると
テストがPASSしています。





## カバレッジの計測

npm install -D @storybook/test-runner @storybook/addon-coverage

※カバレッジインストール後、storybookを再起動させておかないとエラーになります。

scriptsを追加します。

```package.json
{
 "scripts": {
 ...
 "test-storybook": "test-storybook --coverage",
 }
}

```



```.storybook/main.ts

const config: StorybookConfig = {
 addons: [
 ...
 '@storybook/addon-coverage',
 ],
};

```



カバレッジの計測にはstorybookを起動させておく必要があります。
npm run storybook

カバレッジの計測(新しいターミナルで実行します。)
npm run test-storybook


インタラクションテストの動作確認
カバレッジの計測を確認



----------------------------------------

# Supabase

このSupabase項目は

Supabase ローカル開発環境 ＋ サーバー運用を想定 2023 - Qiita
https://qiita.com/masakinihirota/items/be94b4c74a7850a4b79c

を参考にしてください。



ローカルにSupabaseのCLI (command line interface)をインストールします。

scoop bucket add supabase https://github.com/supabase/scoop-bucket.git
scoop install supabase

アップデート
scoop update supabase

Supabase CLIのバージョン
supabase --version



Supabase本体とクライアントとSupabase Authヘルパーのインストール
npm install supabase @supabase/supabase-js @supabase/auth-helpers-nextjs



Supabaseの初期化
supabase init



## サーバー側との接続（必要な場合）
Supabaseへのログイン
supabase login

Supabaseプロジェクトへのリンク
supabase link

## Dockerのインストール

Supabase ローカル開発環境 ＋ サーバー運用を想定 2023 - Qiita
https://qiita.com/masakinihirota/items/be94b4c74a7850a4b79c

を参考にしてください。


## ローカルのSupabaseを始める

supabase start

```
06-18 15:49:49> supabase start
Seeding data supabase\seed.sql...me...
                                 Started supabase local development setup.

         API URL: http://localhost:54321
     GraphQL URL: http://localhost:54321/graphql/v1
          DB URL: postgresql://postgres:postgres@localhost:54322/postgres
      Studio URL: http://localhost:54323
    Inbucket URL: http://localhost:54324
      JWT secret: super-secret-jwt-token-with-at-least-32-characters-long
        anon key: eyJhb**********************************n_I0
service_role key: eyJhbGci*******************************pN81IU

```

ステータス
supabase status

ローカルのSupabase(Docker)を止める
supabase stop

## Supabaseを利用したローカルでの開発

Supabase ローカル開発環境 ＋ サーバー運用を想定 2023 - Qiita
https://qiita.com/masakinihirota/items/be94b4c74a7850a4b79c

を参考にしてください。

## Supabaseクライアントの基礎

src\utils\supabase.tsという新しいファイルを作成し、以下の内容を追加します。

```src\utils\supabase.ts

import { createClient } from '@supabase/supabase-js'

export default createClient(
 process.env.NEXT_PUBLIC_SUPABASE_URL!,
 process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
)

```

これを呼び出すことでSupabaseクライアントが作成できます。





----------------------------------------

# サービスとの連携コマンド

プロジェクトをGitHubで公開して、それをVercelから連携させます。

取得した独自ドメインがあるのならドメイン登録もできます。

vercel関連
Next.js×Supabase×Vercel連携について - Qiita
https://qiita.com/kaho_eng/items/8a7faf77222a599fb31c

npx vercel login

Vercelプロジェクトをローカル環境にクローンしたプロジェクトにリンクします。
npx vercel link

環境変数を連携したVercelプロジェクトからコピーして .env.localに上書きできます。
npx vercel env pull






































# 参考URL

GitHub Qiita記事
Supabase ローカル開発環境 ＋ サーバー運用を想定 2023
https://qiita.com/masakinihirota/items/be94b4c74a7850a4b79c

GitHub masakinihirota/vns
https://github.com/masakinihirota/vns

Supabase VNS
https://app.supabase.com/project/gzctqdrrnnkaxwwtzbsw

Vercel VNS
https://vercel.com/masakinihirota/vns

Next.js by Vercel - The React Framework
https://nextjs.org/

Storybook
https://storybook.js.org/docs/react/get-started/install/

React×TypeScriptではじめるVitest
https://zenn.dev/bs_kansai/articles/b79d97a8f921d6

Storybook(v7)をVitestで再利用するとき
https://zenn.dev/pluto0004/articles/3bab7d07805cff




[2023年]Next.js + eslint周りの設定
https://zenn.dev/resistance_gowy/articles/91b4f62b9f48ec

【環境構築】Next × App Router × Prettier × ESLint × Husky × Shadcn/ui の環境構築をしてみる - Qiita

https://qiita.com/hiroto_dnpk/items/a7ebbca3294c7befb4b7







----------------------------------------

# 未インストール

<details><summary>未インストール[WIP]</summary>

# vitest

テストツール

???
npm create vite@latest

React と TypeScript を選択します。

cd vitest-react
npm install
npm run dev

ここからインストール？
npm install -D vitest

npm install -D jsdom @testing-library/react @testing-library/jest-dom


.eslintignore
ファイル内にvitest.config.tsを書く

```
vite.config.ts
vitest.config.ts
.eslintrc.cjs

```

Vitest の設定
vite.config.ts



```vitest.config.ts
import { defineConfig } from 'vite'

export default defineConfig({
    test: {
        include: ['src/**/*.test.tsx'],
        environment: 'jsdom',
    },
})

```

src/以下のみに設定してある




## テストコードの作成

App コンポーネントに対して、「Vite + React」が表示されているかのテストを書いてみます。



```
import '@testing-library/jest-dom';
import { render, screen } from '@testing-library/react';
import { expect, test } from 'vitest';
import App from '../App';

test('renders h1 text', () => {
    render(<App />);
    const headerElement = screen.getByText("Vite + React");
    expect(headerElement).toBeInTheDocument();
});

```


実行
npx vitest

カバレッジの実行
npx vitest run --coverage




```
import { defineConfig } from 'vite'

export default defineConfig({
    test: {
        globals: true,
        include: ['src/**/*.test.tsx'],
        environment: 'jsdom',
        coverage: {
            reporter: ['html'],
            reportsDirectory: './coverage'
        },
    },
})

```



</details>



