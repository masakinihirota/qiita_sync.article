<!--
title:   AIによる設計書作成能力比較 GitHub Copilot GPT5.1シリーズモデル比較 ＋以前のモデル
tags:    GPT-5.1,codex,githubcopilot
id:      19b076590fbb0d0b1ebb
private: false
-->
追記 2025年11月19日 Gemini 3 Proを評価、比較

GitHub Copilotで Gemini 3 Pro が使えるようになったので設計書を同じ様に作成してもらいました。

![スクリーンショット 2025-11-19 072949.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/44761/5430f725-20e2-4bf5-b53d-3b9f791cdc14.png)

GitHub Copilot で新しく追加された Gemini 3 Pro の評価も追加 5点満点で4.5点 あくまでも要件定義書から設計書を書いた時の比較です。

追記終了

---

追記 2025年11月15日 Raptor-miniを評価、比較

![スクリーンショット 2025-11-15 073104.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/44761/791f30d2-71e4-4cbc-989a-089535d92815.png)

GitHub Copilot で新しく追加された Raptor-mini の評価も追加 5点満点で4.5点 つまり無料モデルの中では最も高性能と評価できる。あくまでも要件定義書から設計書を書いた時の比較です。

追記終了


# 設計書作成能力比較

GPT5.1シリーズがGitHub Copilotでも使えるようになったので能力を試してみました。
今回 コードではなく設計書を書いてもらった結果をまとめています。



## 結論 4.5点以上あれば良いAIモデルだと思われる。

設計書作成能力はそのままコードの作成能力につながっている。
最高の設計書でもそれは1モデルの出力であり、その他のモデルで出力された設計書と合わせることでより良い設計書を作成できる可能性があります。

## 使用プロンプト

```md
#file:アクセス権限要件定義書.md を読んで アクセス権限設計書を書いてください。

```

## アクセス権限設計書の作成時によるモデル別採点結果

NotebookLMに採点してもらいました。

| モデル名称 | 評価点| 倍率 |
| :--- | :--- | :--- |
| **5-Codex** | 5/5点 | x1 |
| **Gemini 3 Pro** | 4.5/5点 | x1 |
| **Raptor-mini** | 4.5/5点 | x0 |
| **Haiku-4.5** | 4.5/5点 | x0.33 |
| **5.1-Codex** | 4.5/5点 | x1 |
| **5.1-Codex-Mini** | 4.5/5点 | x0.33 |
| GPT-5-mini | 4/5点 | x0 |
| 5.1 | 4/5点 | x1 |
| Grok Code | 3/5点 | x0 |
| GPT-4o | 2/5点 | x0 |
| GPT-4.1 | 1/5点 | x0 |



## 📓 用語集（アクセス権限設計/AIモデル比較）

| 用語 | カテゴリ | 記事内での意味・文脈 |
| :--- | :--- | :--- |
| **RBAC** | アクセス制御 | **Role-Based Access Control**（ロールベースアクセス制御）。ユーザーの**役割（ロール）** に基づいてアクセス権限を付与する基本的なセキュリティモデル。一般的なRBAC設計では、この記事で要求される複雑な要件（RLS、否定権限）には不十分とされる。 |
| **RLS** | セキュリティ | **Row-Level Security**（行レベルセキュリティ）。データベースの機能であり、アプリケーション層での判定にかかわらず、**DB（データベース）側で最終的にアクセス可能なデータの行を制限**する仕組み。`所属コンテキスト（国/組織）の最終検証`のために必須とされている。 |
| **論理ロール属性** | アクセス制御 | システムロール（R1〜R7）とは別に、`国/組織のリーダー`や`調停者`といった、**ユーザーの業務上の属性や所属コンテキスト**を定義するもの。システムロールと組み合わせて権限を細分化（ハイブリッド化）するために使用される。 |
| **否定権限の優先 (FR-04)** | アクセス制御 | **Deny takes precedence** 。ユーザーが複数のロールを持ち、その権限に **「許可（Allow）」と「禁止（Deny）」が衝突** した場合に、**「禁止（Deny）」を優先** してアクセスを拒否するというセキュリティルール（機能要件 **FR-04**）。 |
| **トレーサビリティ表** | 設計/文書化 | 要件定義書の**各要件**（FR/DL/TR/OR）が、設計書の**どの要素**（モジュール/カラム）や**どのテストケース**に対応しているかを明確に示した一覧表。設計の抜け漏れがないかを検証するために特に重要。 |
| **マテリアライズドビュー** | 性能/DB | データベースにおける**キャッシュ戦略**の一つ。複雑なクエリの結果をあらかじめ計算して物理的なテーブルとして保存しておく仕組み。`NFR-01: 200ms以内の性能`を達成するための技術的な最適化策として提案された。 |
| **Codex / Mini** | AIモデル名 | 記事内の評価で高得点を得たAIモデルの名称に冠される接尾辞。これらのモデルは、一般的なモデルに比べて**詳細な技術設計やコーディングに特化**した能力を持つことが示唆されている。 |

---

ご提示いただいたアクセス権限設計書を作成したAIモデル（設計書のモデル）の一覧と、前回の評価に基づいた採点結果をまとめます。

これらの設計書は、複雑な要件定義書（REQ-AC-0012）への対応度を比較するために、異なるAIモデルによって生成されました。

## アクセス権限設計書 使用モデル一覧

| 設計書ID | モデル名称 | 評価点 (5点満点) | 設計上の主な特徴 |
| :--- | :--- | :--- | :--- |
| **設計書-1** | GPT-4.1 | 1/5点 | RBACの基本的な概念説明に終始し、要件定義書の複雑な要素（RLS、論理ロール、DL-08など）が欠落。 |
| **設計書-2** | GPT-4o | 2/5点 | ロールとリソースの分類には触れるが、論理ロールとのマッピングやRLSの具体的な方針が不明確。 |
| **設計書-3** | **GPT-5-mini** | 4/5点 | RLSの使用を前提とし、論理ロール属性をデータモデルに組み込んだ。**否定権限の優先ルール（FR-04）** に言及。 |
| **設計書-4** | Grok Code | 3/5点 | モジュール設計やデータフローが整理され、ポイント管理処理における**二重記帳**に言及。判定アルゴリズムに具体性が不足。 |
| **設計書-5** | **Haiku-4.5** | 4.5/5点 | **RBAC層と論理ロール層の2層構造**を明確化。定時バッチ処理（自動失効、ポイント回復）の設計が具体的な高評価モデル。 |
| **設計書-6** | **5-Codex** | **5/5点** | **最高評価**。権限判定を「ロールマージ → コンテキスト制約 → RLS最終検証」の**3層構造**として明確化。DL-08要件とテストケースの**トレーサビリティ表**を備える。 | |
| **設計書-7** | 5.1 | 4/5点 | 最小権限原則、RLS、履歴監査の4つの基本方針を明確化。**FR-04（否定優先）** のロジック説明が論理的である。 |
| **設計書-8** | **5.1-Codex** | 4.5/5点 | RLS連携と否定優先を明言。**DL-08（ポイント監査）**に対応する詳細な`ledger_entries`の**カラム定義**が含まれており、監査要件への対応が強力。 |
| **設計書-9** | **5.1-Codex-Mini** | 4.5/5点 | 2層認可アーキテクチャ と、**性能目標（NFR-01）** 達成のための**マテリアライズドビュー（キャッシュ戦略）** の使用を提案。 |

### モデルの傾向に関する洞察

要件定義書（REQ-AC-0012）に含まれる高度なセキュリティ要件（RLS、否定権限優先、論理ロール属性）に対応できたのは、主にCodexやMiniを冠する**詳細な技術設計に特化したモデル**でした。

*   **GPT-4.1 / GPT-4o** モデルは、一般的なRBAC設計の範疇に留まり、要件の核心である**所属コンテキスト制御 (FR-05)**や**二重記帳 (DL-08)** の具体的な実装方針を提示できませんでした。
*   **5-Codex** は、最も包括的で実装のトレーサビリティを重視した設計を提供し、複雑な要件を**コンポーネントの責務**に分けて落とし込む能力が際立っていました。
*   **5.1-Codex-Mini** は、単なる要件充足に留まらず、**非機能要件（NFR-01: 200ms以内の性能）** を達成するための技術的な最適化策（マテリアライズドビューによるキャッシュ）を提案しており、実運用を見据えた設計能力を示しています。

これらの結果から、セキュリティや監査要件が複雑なシステム設計においては、AIモデルの選定が設計品質に直結することが示唆されます。

---

本記事は、極めて複雑なアクセス権限要件定義書（REQ-AC-0012）をAIに渡し、生成された9つの設計書を詳細に評価・比較した結果を共有するものです。AIがどれだけ高度なセキュリティ設計の要件（ロールのハイブリッド化、サーバー側最終検証、厳格な監査ログ）に対応できたか、その検証結果を解説します。

---

## AIに複雑なアクセス権限設計を依頼：9つの設計案を徹底評価

### 1. 挑戦的な要件：なぜ通常のRBAC設計では不十分なのか

AIに要求した要件定義書は、単なるロールベースアクセス制御（RBAC）では済まされない、以下の**複雑な要件**を含んでいます。

| 要件カテゴリ | 概要 |
| :--- | :--- |
| **ロールのハイブリッド化** | システムロール（R1〜R7）を基盤としつつ、国/組織のリーダーや調停者といった**論理ロール属性**を組み合わせ、R7（一般ユーザー）の権限を細分化する。 |
| **否定権限の優先** | 複数ロールを持つ場合、許可と禁止が衝突した際には、**否定権限（Deny）を優先**してアクセスを拒否する（FR-04）。 |
| **最終防御線（RLS）** | アプリケーション側で権限判定を行っても、データベース側でRow-Level Security (RLS) による**所属コンテキスト（国/組織）の最終検証**を必須とする。 |
| **厳格な監査追跡** | ポイントの移動や徴収に関わる操作ログ（DL-08）は、送信側と受信側の双方にエントリを生成する**二重記帳トランザクション**を必須とする。 |

これらの複雑な要件に対し、AIがどれだけ具体的かつ実装可能な設計を提示できたかが、今回の評価の焦点となりました。

---

### 2. 評価基準：4つの設計の柱

9つの設計書を評価するため、REQ-AC-0012 で定義された要件のうち、実装の難易度とセキュリティへの影響が高い以下の4つを設計の柱と定め、5点満点で採点しました。

1.  **ハイブリッド制御の実現性**: システムロール（R1〜R7）と論理ロール属性（nationRole, orgRole）をどのようにデータモデルに統合し、権限判定に利用しているか。
2.  **RLSによる最終防御線の具体性**: RLSの使用を前提とし、所属コンテキスト制御（FR-05）をDBレイヤでどのように担保するか。
3.  **複雑な業務フローへの対応**: 例外承認（FR-06）の自動失効処理 や、ポイント管理の二重記帳（DL-08） といった、業務ロジックの具体性。
4.  **監査と履歴の完全性**: ログの改ざん防止（DL-02）や、すべての権限変更のトレーサビリティ（DL-01, TR-04）が確保されているか。



---

### 3. アクセス権限設計書 採点結果サマリー

| 設計書 | 評価レベル | 採点 (5点満点) | 主な評価理由 | 参照ソース |
| :--- | :--- | :--- | :--- | :--- |
| **設計書-1** | 概念的 | 1/5点 | 基本的なRBACの説明に終始し、要件の核となるRLS、論理ロール、DL-08が完全に欠落。 | |
| **設計書-2** | 概要レベル | 2/5点 | ロールとリソースの分類には触れるが、論理ロールとのマッピングやRLSの具体的な方針が不明確。 | |
| **設計書-3** | 詳細な技術設計 | 4/5点 | **RLSの使用**と論理ロール属性をデータモデルに組み込んでいる。**否定権限の優先ルール（FR-04）** にも言及。 | |
| **設計書-4** | 標準的設計 | 3/5点 | モジュール設計が整理されており、ポイント管理処理における**二重記帳**に言及。判定アルゴリズムに具体性が不足。 | |
| **設計書-5** | **高評価** | 4.5/5点 | **RBAC層と論理ロール層の2層構造**、RLS統合方針が明確。定時バッチ処理（自動失効、ポイント回復、月末徴収）の設計が具体的。 | |
| **設計書-6** | **最高評価** | 5/5点 | 複雑な要件に対し**最も包括的**。「ロールマージ → コンテキスト制約 → RLS最終検証」の**3層構造**を定義。**専用のLedger Controlモジュール**と、要件との**トレーサビリティ表**が優れている。 | |
| **設計書-7** | 論理的 | 4/5点 | 最小権限原則、RLS、履歴監査の**4つの基本方針**を明確化。例外承認（FR-06）のモデルと判定ロジックが明確。 | |
| **設計書-8** | **高評価** | 4.5/5点 | **DL-08（ポイント監査）**に対応するため、`ledger_entries`に`consent_trace_id`や`workflow_id`など**詳細なカラム定義**を提案。7段階の権限判定ロジックが詳細。 | |
| **設計書-9** | 統合・最適化 | 4.5/5点 | **NFR-01の性能要件（200ms以内）**を満たすための**マテリアライズドビュー**（キャッシュ戦略）の使用を提案。運用・監視（OR-05/06）の設計が具体的。 | |

### 4. ベストプラクティス：最高評価を得た設計書（設計書-6）の強み

最高評価（5/5点）を得た**設計書-6 (5-Codex)** は、要件定義書が要求する複雑なセキュリティロジックを、実装・監査・運用すべての観点から具体的に落とし込んでいました。

#### 4.1. 判定ロジックの「3層構造」による堅牢性

設計書-6 は、権限判定を以下の3層で実行すると定義しました。これは、FR-04（否定優先）とFR-05（RLS最終検証）の要件を両立させる、最も堅牢なアプローチです。

1.  **ロール優先度マージ**: システムロール（R1〜R7）の権限を優先度順に取得し、否定権限（Deny）を優先適用して許可セットを形成する。
2.  **所属コンテキスト制約**: ユーザーの論理ロール属性（nationRole, orgRole）と、アクセス対象リソースの所属コンテキスト（国ID/組織ID）を照合し、権限をフィルタリングする。
3.  **RLSによる最終検証**: アプリケーション層での判定結果にかかわらず、データベースの行レベルセキュリティ（RLS）が最終的なアクセス可否を保証する。

#### 4.2. DL-08要件を完全に満たす監査設計

設計書-6 は、ポイント台帳の厳格な監査要件（DL-08） に対応するため、専用の`Ledger Control`モジュールを定義しました。

*   ポイント操作は全て`ledger_entries`テーブルに記録され、**送信側/受信側それぞれにエントリを生成**し、共通の`transactionId`で結びつける（二重記帳）。
*   操作ログ（`audit_events`）には、改ざん防止のため `SHA256(transaction_id || payload_json)` を用いた**ハッシュ**を付与し、追跡可能性（TR-04）を担保します。

#### 4.3. 優れたトレーサビリティ

設計書-6 は、**要件（FR/DL/TR/OR）と設計要素、テストケースの対応表**を詳細に備えており、レビューや実装時に要件の抜け漏れがないかを即座に確認できる点で群を抜いています。

### 5. 総括と推奨される設計戦略

今回の検証結果から、AIが生成する設計書の品質には大きな差があり、特に複雑なセキュリティ要件においては、単なるRBACの枠組みを超えた**具体的な技術要素の統合**（RLSや論理ロール属性）が成功の鍵となることが明らかになりました。

最も推奨される設計戦略は、**設計書-6** をベースとしつつ、以下の点を強化・統合することです。

1.  **性能目標（NFR-01）の担保**: 設計書-9 が提案する、権限判定結果をキャッシュするための**マテリアライズドビュー**（`user_authorization_permissions`）を採用し、200ms以内の応答時間を実現する。
2.  **ポイント監査項目の網羅**: 設計書-8 が具体化したように、`ledger_entries`には**同意トレースID** (`consent_trace_id`) や**ワークフローID** (`workflow_id`) を含め、ポイント操作の透明性を最大限に高める。

高度なアクセス権限設計は、システムセキュリティの **「制御盤」** そのものです。システムロールが機能の利用範囲を、論理ロールが業務上の責任範囲を定義し、RLSがデータベースという「金庫」の最終アクセスを物理的に制御する、この多層的な構造を設計書に落とし込むことが、安全で監査可能なシステムの実現に不可欠となります。



---

## Xでの報告

Xユーザーのmasakinihirotaさん: 「GitHub Copilotで200行程の要件定義書から複数のmodelを使い 設計書を1回の試行で書いてもらった結果。 ここに載ってないmodelは1回目の試行で長過ぎて止まってしまったもの //評価はNotebookLMに聞いたもの 最高得点は5-Codexが満点という評価を出した。要件定義書はAIと壁打ちしながら作ったもの

https://x.com/masakinihirota/status/1989144362333393113

---

## おまけ

### 質問

どの設計書で実装するのがいいか？また同じモデルで実装したほうがいいか？それとも違うモデル、例えばコード実装特化のモデルを利用したほうがいいか？

### 回答

お問い合わせありがとうございます。提示された複雑な要件定義書（REQ-AC-0012）に基づき、どのアクセス権限設計書を採用すべきか、また実装フェーズでどのAIモデルを使用すべきかについて、これまでの評価結果とソースの情報を踏まえてご提案します。

## 1. どの設計書で実装するのがいいか？

これまでの評価（採点結果）に基づき、**設計書-6 (5-Codex)** をどの設計書で実装するのがいいか？

これまでの評価（採点結果）に基づき、**設計書-6 (5-Codex)** を**ベース**として採用し、**設計書-9 (5.1-Codex-Mini)**の**性能最適化戦略**を統合することを強く推奨します。

### 採用推奨設計書：設計書-6 (5-Codex)

設計書-6 は、要件定義書のすべての複雑な要素に対する**最も包括的でトレース可能な**アプローチを提供しているため、実装の基盤として最適です。

*   **三層構造による堅牢性**: 権限判定を「ロール優先度マージ → 所属コンテキスト制約 → RLS による最終検証」の**3層構造**として明確に定義しており、FR-04（否定権限優先） と FR-05（RLS最終検証） の両方の要件を漏れなく満たす具体的な戦略が示されています。
*   **DL-08（ポイント監査）への対応**: 専用の **Ledger Control モジュール** を定義し、ポイント台帳操作が DL-08 に従い**二重記帳**され、`entry_id`, `transaction_id`, `status`, `workflow_id` など要件で定義された項目を保持する `ledger_entries` テーブルが設計されています,。
*   **トレーサビリティ**: FR, DL, TR, ORの各要件と設計要素、テストケースを紐づけた**トレーサビリティ表**を備えている点 は、実装後のレビューや監査対応において、要件の抜け漏れを防ぐ上で極めて強力です。

### 統合すべき要素：設計書-9 (5.1-Codex-Mini) の性能戦略

設計書-6 は機能要件の網羅性に優れますが、設計書-9 は**非機能要件（NFR-01: 200ms以内）** への具体的な対応策を提示しています。

*   **パフォーマンス最適化**: 設計書-9 は、権限判定の性能目標を満たすために、**`user_authorization_permissions` マテリアライズドビュー**（キャッシュ戦略）の使用を提案しています,。複雑なハイブリッド権限判定 の都度DBアクセスを行うと性能要件を達成できないリスクが高いため、このキャッシュ戦略を設計書-6のアーキテクチャに組み込むべきです。

### 実装推奨設計書の結論

**「設計書-6 の堅牢な構造」** に **「設計書-9 の性能最適化（キャッシュ戦略）」** を加えて実装を進めることを推奨します。

---

## 2. 実装に同じモデルを使うべきか、異なるモデルを使うべきか？

**設計書の作成**と**コードの実装**は異なるフェーズであり、それぞれのタスクに特化したモデルを利用することで、品質と効率の向上が期待できます。

### 2.1. モデルの傾向と評価の示唆

これまでの評価結果から、以下の傾向が見られます。

*   **設計書の作成**: 複雑な要件定義書（特に論理ロール、RLS、DL-08といった高度な監査要件）に対応できたのは、**GPT-5-mini、Haiku-4.5、5-Codex、5.1-Codex、5.1-Codex-Mini**といった、詳細な技術設計やコーディングサポートに特化していると思われるモデル群でした,,,,。
*   **モデルの粒度**: 設計書-6 (5-Codex) のように、要件の全体像を捉えつつ、各コンポーネントの責務分離（Ledger Controlモジュールなど）やトレーサビリティを重視した設計は、**Codex系モデル**の強みであると考えられます,。

### 2.2. 実装フェーズでのモデル選択

設計書は、実装者が読むべき技術仕様であり、実装フェーズでは、この仕様に正確に従い、性能・保守性の高いコードを生成することが求められます。

#### 結論：設計書作成に成功したモデル群の利用を推奨

設計書-6, 8, 9 を作成したモデル（5-Codex, 5.1-Codex, 5.1-Codex-Mini）は、要件定義書を深く理解している証拠となる具体的な技術設計（PostgreSQL RLSの利用、二重記帳のテーブル詳細）を提示しています,。

これらのモデル、あるいは同様に**コード実装と設計詳細に特化したモデル**をコード実装フェーズで利用することで、以下のメリットが期待できます。

1.  **要件理解度の継続**: 設計の意図（例：RLSが最終防御線であること）を深く理解したままコードに落とし込めるため、設計と実装の乖離を防ぎやすい。
2.  **複雑なロジックの生成**: FR-04の否定優先ロジック や、ポイント管理の二重記帳トランザクション（DL-08） といった複雑でミスの許されないロジックを、設計書に忠実に、かつ効率的に生成できる可能性が高まります。
3.  **技術選定との親和性**: 設計書がPostgreSQL RLS, や Drizzle ORM を前提としている場合、これらの技術スタックに習熟したモデル（Codex系など）を使用する方が、適切なコードスニペットやマイグレーションスクリプト（DDL）の生成において優位です。

したがって、**設計書作成で高い評価を得たモデル群（またはその系統のコード特化モデル）** を、実際のコード生成やレビューの補助に利用することが、プロジェクト成功の鍵となります。

---

## NotebooLMでのスクリーンショット

![スクリーンショット 2025-11-14 102740.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/44761/78a510f6-3975-4f63-a95c-7d696b2aa8d4.png)